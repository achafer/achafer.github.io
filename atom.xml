<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>远山淡影</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.ache.fun/"/>
  <updated>2018-11-18T10:34:59.864Z</updated>
  <id>https://blog.ache.fun/</id>
  
  <author>
    <name>阿扯</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>布莱叶盲文</title>
    <link href="https://blog.ache.fun/2018/11/18/%E5%B8%83%E8%8E%B1%E5%8F%B6%E7%9B%B2%E6%96%87/"/>
    <id>https://blog.ache.fun/2018/11/18/布莱叶盲文/</id>
    <published>2018-11-18T07:39:09.000Z</published>
    <updated>2018-11-18T10:34:59.864Z</updated>
    
    <content type="html"><![CDATA[<p>最近在读《编码》这本书，书中有关于盲文的介绍，平时在生活中见到盲文也十分好奇，因此在这里记录下解析盲文编码：</p><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>在布莱叶发明盲文之前有一个叫霍伊的盲人学校的校长发明了一种在纸面上印下凸起文字的系统，不过霍伊视力健全，因此他被自身的感知模式所禁锢，对他来说，一个字母A在纸上也必须摸起来像A，后来被证实，这种文字系统根本不适合盲人阅读。之后一位名叫巴比尔的法国军队军官为了部队的无声交流发明了一种在厚纸上通过凸起的点和划的组合来表示文字，不过这套系统因为设计过于复杂，用来传递简短的信息效果还不错，可是长文本的时候就显得力不从心了。</p><p>布莱叶在12岁的时候就熟悉了巴比尔设计的文字系统，在这之后他开始不辞辛劳的改进这个系统，3年之后他就发明了自己的一套系统，这个系统中的一些基本规范，直到今天仍在使用。</p><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>在布莱文盲文中，字母、数字、符号都被编码成为2*3的电码单元中一个或者多个凸起的点，这个点码单元包含的点通常使用1到6的数字来编号。</p><p><img src="/images/braille-code.png" alt=""></p><p>在现代应用中，使用特殊的打印机可以将它印到较厚的纸张上。这些点码时二进制的，一个单独的点不是平的就是凸起的，我们知道每组有6个点，并且每个点有平和凸两种状态，因此6个可平可凸的点的组合数就是2<sup>6</sup>，也就是64。因此，布莱叶盲文系统能够表示64个不同的码字。</p><h5 id="小写字母"><a href="#小写字母" class="headerlink" title="小写字母"></a>小写字母</h5><p><img src="/images/code-alphabet.png" alt="code-alphabet"></p><p>图片来源：<a href="https://zh.wikipedia.org/wiki/%E7%9B%B2%E6%96%87" target="_blank" rel="noopener">维基百科盲文词条</a></p><p>例如词组“you and me”用布莱叶盲文表示成如下组合：</p><center><br><font size="6">⠽⠕⠥  ⠁⠝⠙   ⠍⠑</font><br></center><p>单词之间用一个空白的点码单元隔开。</p><p>仔细观察上表会发现一个规律，第一排（字母a到j）只用到了点码单元中最上面的四个点。第二排在复用了第一排的基础上，把第三个改为凸点。第三排也沿用了同样的规律，把第3个和第6个改为凸点。那为什么w没有遵循这样的规律呢，因为布莱叶是法国人，在传统法语中不会用到它。</p><p>目前使用的最常用的盲文被称为二级布莱叶盲文（Grade 2 Braille）在传统盲文上，二级布莱叶盲文使用了很多缩写。</p><h5 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h5><p>数字盲文和a-j的盲文一致，不过要在特定的符号 ⠼ 之后:</p><table><thead><tr><th>⠁</th><th>⠃</th><th>⠉</th><th>⠙</th><th>⠑</th><th>⠋</th><th>⠛</th><th>⠓</th><th>⠊</th><th>⠚</th></tr></thead><tbody><tr><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td><td>8</td><td>9</td><td>0</td></tr></tbody></table><p>所以256表示为：</p><center><br>    <font size="6">⠼⠃⠑⠋</font><br></center><h3 id="汉语盲文"><a href="#汉语盲文" class="headerlink" title="汉语盲文"></a>汉语盲文</h3><p>汉语的盲文是通过拼音加音调来编码的，所以盲人对汉字也一无所知，同音字区分也就比较困难了。可通过<a href="http://mathedit.lzu.edu.cn:8080/braille-web/blinds/index.html?userId=0&amp;username=" target="_blank" rel="noopener">中国盲文数字平台</a>来查询盲文。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近在读《编码》这本书，书中有关于盲文的介绍，平时在生活中见到盲文也十分好奇，因此在这里记录下解析盲文编码：&lt;/p&gt;
&lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;在布莱叶发明盲文
      
    
    </summary>
    
    
      <category term="编码" scheme="https://blog.ache.fun/tags/%E7%BC%96%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>golang中使用gRPC的拦截器</title>
    <link href="https://blog.ache.fun/2018/11/04/golang%E4%B8%AD%E4%BD%BF%E7%94%A8gRPC%E7%9A%84%E6%8B%A6%E6%88%AA%E5%99%A8/"/>
    <id>https://blog.ache.fun/2018/11/04/golang中使用gRPC的拦截器/</id>
    <published>2018-11-04T11:35:47.000Z</published>
    <updated>2018-11-05T01:12:23.146Z</updated>
    
    <content type="html"><![CDATA[<p>最近工作使用gRPC来做通信，一开始在研究认证时，发现了gRPC的拦截器，在这里记录下其用法，后续备忘</p><h3 id="拦截器的分类"><a href="#拦截器的分类" class="headerlink" title="拦截器的分类"></a>拦截器的分类</h3><p>在gRPC中有两种拦截器<code>UnaryInterceptor</code>和<code>StreamInterceptor</code>，其中UnaryInterceptor拦截普通的一次请求一次响应的rpc服务，StreamInterceptor拦截流式的rpc服务。</p><h3 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h3><p>在包<code>google.golang.org/grpc</code>中，给Server提供了两个适用于Unary和Stream的拦截器函数分别是<code>UnaryInterceptor</code>和<code>StreamInterceptor</code></p><h5 id="UnaryInterceptor"><a href="#UnaryInterceptor" class="headerlink" title="UnaryInterceptor"></a>UnaryInterceptor</h5><p>UnaryInterceptor函数的唯一参数是一个<code>UnaryServerInterceptor</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">UnaryInterceptor</span><span class="params">(i UnaryServerInterceptor)</span> <span class="title">ServerOption</span></span> &#123;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UnaryInterceptor返回的<code>ServerOption</code>作为<code>grpc.NewServer</code>的参数。</p><p>而UnaryServerInterceptor是一个函数类型：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> UnaryServerInterceptor <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, req <span class="keyword">interface</span>&#123;&#125;, info *UnaryServerInfo, handler UnaryHandler)</span> <span class="params">(resp <span class="keyword">interface</span>&#123;&#125;, err error)</span></span></span><br></pre></td></tr></table></figure><p>其中四个参数分别是</p><ul><li>ctx: 当前请求的Context</li><li>req：当前请求的参数</li><li>info：当前请求的服务端信息</li><li>handler：服务端处理这次请求的handler</li></ul><p>来自<a href="https://medium.com/@shijuvar/writing-grpc-interceptors-in-go-bf3e7671fe48" target="_blank" rel="noopener">shijuvar@medium</a>的一个简单的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Authorization unary interceptor function to handle authorize per RPC call</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">serverInterceptor</span><span class="params">(ctx context.Context,</span></span></span><br><span class="line"><span class="function"><span class="params">req <span class="keyword">interface</span>&#123;&#125;,</span></span></span><br><span class="line"><span class="function"><span class="params">info *grpc.UnaryServerInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">handler grpc.UnaryHandler)</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class="line">start := time.Now()</span><br><span class="line"><span class="comment">// Skip authorize when GetJWT is requested</span></span><br><span class="line"><span class="keyword">if</span> info.FullMethod != <span class="string">"/proto.EventStoreService/GetJWT"</span> &#123;</span><br><span class="line"><span class="keyword">if</span> err := authorize(ctx); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Calls the handler</span></span><br><span class="line">h, err := handler(ctx, req)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Logging with grpclog (grpclog.LoggerV2)</span></span><br><span class="line">grpcLog.Infof(<span class="string">"Request - Method:%s\tDuration:%s\tError:%v\n"</span>,</span><br><span class="line">info.FullMethod,</span><br><span class="line">time.Since(start),</span><br><span class="line">err)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> h, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// authorize function authorizes the token received from Metadata</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">authorize</span><span class="params">(ctx context.Context)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">md, ok := metadata.FromIncomingContext(ctx)</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">return</span> status.Errorf(codes.InvalidArgument, <span class="string">"Retrieving metadata is failed"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">authHeader, ok := md[<span class="string">"authorization"</span>]</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">return</span> status.Errorf(codes.Unauthenticated, <span class="string">"Authorization token is not supplied"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">token := authHeader[<span class="number">0</span>]</span><br><span class="line"><span class="comment">// validateToken function validates the token</span></span><br><span class="line">err := validateToken(token)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> status.Errorf(codes.Unauthenticated, err.Error())</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>gRPC支持在Context中发送<code>metadata</code>, <code>google.golang.org/grpc/metadata</code>包提供了操作metadata的功能。</p><h3 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h3><p>在Client中全局传递metadata</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithPerRPCCredentials</span><span class="params">(creds credentials.PerRPCCredentials)</span> <span class="title">DialOption</span></span> &#123;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中参数是个interface：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> PerRPCCredentials <span class="keyword">interface</span> &#123;</span><br><span class="line">GetRequestMetadata(ctx context.Context, uri ...<span class="keyword">string</span>) (<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>, error)</span><br><span class="line">RequireTransportSecurity() <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后示例代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// customCredential 自定义认证</span></span><br><span class="line"><span class="keyword">type</span> customCredential <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="comment">// GetRequestMetadata 实现自定义认证接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c customCredential)</span> <span class="title">GetRequestMetadata</span><span class="params">(ctx context.Context, uri ...<span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line">        <span class="string">"authorization"</span>:  <span class="string">"xxxxx"</span>,</span><br><span class="line">    &#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// RequireTransportSecurity 自定义认证是否开启TLS</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c customCredential)</span> <span class="title">RequireTransportSecurity</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">conn, err := grpc.Dial(<span class="string">"localhost:50051"</span>, grpc.WithInsecure(), grpc.WithPerRPCCredentials(<span class="built_in">new</span>(customCredential)))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">"Dial error: %+v\n"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> conn.Close()</span><br><span class="line">c := pb.NewExpStreamClient(conn)</span><br><span class="line">r, err := c.RpcMethod(context.Background()....)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">"say unary error %v\n"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了通过<code>grpc.WithPerRPCCredentials</code>全局传递metadata外，还可以通过每次context传递metadata</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ctx := context.Background()</span><br><span class="line">md := metadata.Pairs(<span class="string">"authorization"</span>, jwtToken)</span><br><span class="line">ctx = metadata.NewOutgoingContext(ctx, md)</span><br><span class="line"><span class="comment">// Calls RPC method CreateEvent using the stub client</span></span><br><span class="line">resp, err := client.CreateEvent(context.Background(), event)</span><br></pre></td></tr></table></figure><h3 id="go-grpc-middleware"><a href="#go-grpc-middleware" class="headerlink" title="go-grpc-middleware"></a>go-grpc-middleware</h3><p><a href="https://github.com/grpc-ecosystem/go-grpc-middleware" target="_blank" rel="noopener">go-grpc-middleware</a>包装了一些列拦截器的链式操作，示例代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grpc.UnaryInterceptor(grpc_middleware.ChainUnaryServer(loggingUnary, monitoringUnary, authUnary),</span><br><span class="line">)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近工作使用gRPC来做通信，一开始在研究认证时，发现了gRPC的拦截器，在这里记录下其用法，后续备忘&lt;/p&gt;
&lt;h3 id=&quot;拦截器的分类&quot;&gt;&lt;a href=&quot;#拦截器的分类&quot; class=&quot;headerlink&quot; title=&quot;拦截器的分类&quot;&gt;&lt;/a&gt;拦截器的分类&lt;/h
      
    
    </summary>
    
    
      <category term="Go" scheme="https://blog.ache.fun/tags/Go/"/>
    
      <category term="gRPC" scheme="https://blog.ache.fun/tags/gRPC/"/>
    
  </entry>
  
  <entry>
    <title>如何开发一个Ruby Gem</title>
    <link href="https://blog.ache.fun/2018/10/28/%E5%A6%82%E4%BD%95%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AARuby-Gem/"/>
    <id>https://blog.ache.fun/2018/10/28/如何开发一个Ruby-Gem/</id>
    <published>2018-10-28T14:27:15.000Z</published>
    <updated>2018-11-04T08:14:51.311Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Gem介绍"><a href="#Gem介绍" class="headerlink" title="Gem介绍"></a>Gem介绍</h3><p>Gem是Ruby源代码库的打包格式，其内部有以下组件</p><ul><li>源代码（包括测试和工具代码）</li><li>文档</li><li>gemspec</li></ul><p>其中gemspec中描述了Gem的名字，版本，平台，依赖等信息。它也是由Ruby编写。</p><p>手动创建一个Gem，<a href="https://guides.rubygems.org/make-your-own-gem/" target="_blank" rel="noopener">官方教程</a>已经写的很明白了，最后写好的Gem的目录结构如下</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ tree</span><br><span class="line">.</span><br><span class="line">├── Rakefile<span class="comment"># Rake的构建文件</span></span><br><span class="line">├── bin<span class="comment"># Gem的可执行文件</span></span><br><span class="line">│   └── hola</span><br><span class="line">├── hola-0.0.0.gem</span><br><span class="line">├── hola.spec<span class="comment"># Gem的描述文件</span></span><br><span class="line">├── lib    <span class="comment"># 源代码主要目录</span></span><br><span class="line">│   ├── hola<span class="comment"># 二级引入的目录</span></span><br><span class="line">│   │   └── translator.rb  <span class="comment"># 使用时对应require 'hola/translator'</span></span><br><span class="line">│   └── hola.rb<span class="comment"># 使用时直接require 'hola'时引入的文件</span></span><br><span class="line">└── <span class="built_in">test</span><span class="comment"># Gem的测试目录</span></span><br><span class="line">    └── test_hola.rb</span><br><span class="line"></span><br><span class="line">4 directories, 7 files</span><br></pre></td></tr></table></figure><h3 id="使用bundler管理Gem"><a href="#使用bundler管理Gem" class="headerlink" title="使用bundler管理Gem"></a>使用bundler管理Gem</h3><h5 id="生成Gem模版"><a href="#生成Gem模版" class="headerlink" title="生成Gem模版"></a>生成Gem模版</h5><p>使用<a href="https://bundler.io" target="_blank" rel="noopener">bundler</a> 工具可以快速的生成一个Gem的模版</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ bundle gem mygem</span><br></pre></td></tr></table></figure><p>生成的目录结构和上文一致，gemspec文件的描述如下:</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">lib = File.expand_path(<span class="string">"../lib"</span>, __FILE_<span class="number">_</span>)</span><br><span class="line">$LOAD_PATH.unshift(lib) <span class="keyword">unless</span> $LOAD_PATH.<span class="keyword">include</span>?(lib)</span><br><span class="line"><span class="keyword">require</span> <span class="string">"mygem/version"</span></span><br><span class="line"></span><br><span class="line">Gem::Specification.new <span class="keyword">do</span> <span class="params">|spec|</span></span><br><span class="line">  spec.name          = <span class="string">"mygem"</span></span><br><span class="line">  spec.version       = Mygem::VERSION</span><br><span class="line">  spec.authors       = [<span class="string">"jeffery"</span>]</span><br><span class="line">  spec.email         = [<span class="string">"i@ache.fun"</span>]</span><br><span class="line"></span><br><span class="line">  spec.summary       = <span class="string">%q&#123;TODO: Write a short summary, because RubyGems requires one.&#125;</span></span><br><span class="line">  spec.description   = <span class="string">%q&#123;TODO: Write a longer description or delete this line.&#125;</span></span><br><span class="line">  spec.homepage      = <span class="string">"TODO: Put your gem's website or public repo URL here."</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> spec.respond_to?(<span class="symbol">:metadata</span>)</span><br><span class="line">    spec.metadata[<span class="string">"allowed_push_host"</span>] = <span class="string">"TODO: Set to 'http://mygemserver.com'"</span></span><br><span class="line"></span><br><span class="line">    spec.metadata[<span class="string">"homepage_uri"</span>] = spec.homepage</span><br><span class="line">    spec.metadata[<span class="string">"source_code_uri"</span>] = <span class="string">"TODO: Put your gem's public repo URL here."</span></span><br><span class="line">    spec.metadata[<span class="string">"changelog_uri"</span>] = <span class="string">"TODO: Put your gem's CHANGELOG.md URL here."</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    raise <span class="string">"RubyGems 2.0 or newer is required to protect against "</span> \</span><br><span class="line">      <span class="string">"public gem pushes."</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Specify which files should be added to the gem when it is released.</span></span><br><span class="line">  <span class="comment"># The `git ls-files -z` loads the files in the RubyGem that have been added into git.</span></span><br><span class="line">  spec.files         = Dir.chdir(File.expand_path(<span class="string">'..'</span>, __FILE_<span class="number">_</span>)) <span class="keyword">do</span></span><br><span class="line">    <span class="string">`git ls-files -z`</span>.split(<span class="string">"\x0"</span>).reject &#123; <span class="params">|f|</span> f.match(<span class="regexp">%r&#123;^(test|spec|features)/&#125;</span>) &#125;</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  spec.bindir        = <span class="string">"exe"</span></span><br><span class="line">  spec.executables   = spec.files.grep(<span class="regexp">%r&#123;^exe/&#125;</span>) &#123; <span class="params">|f|</span> File.basename(f) &#125;</span><br><span class="line">  spec.require_paths = [<span class="string">"lib"</span>]</span><br><span class="line"></span><br><span class="line">  spec.add_development_dependency <span class="string">"bundler"</span>, <span class="string">"~&gt; 1.16"</span></span><br><span class="line">  spec.add_development_dependency <span class="string">"rake"</span>, <span class="string">"~&gt; 10.0"</span></span><br><span class="line">  spec.add_development_dependency <span class="string">"minitest"</span>, <span class="string">"~&gt; 5.0"</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>在文件中<code>spec</code>的字段描述了的Gem基本信息，除了文件中这些字段，其他的字段<a href="https://guides.rubygems.org/specification-reference/" target="_blank" rel="noopener">参考链接</a>。</p><p>文件中的<code>spec.files</code>字段，是当前Gem源代码的所有文件列表（而不是目录），所以使用了<code>git ls-files -z</code>命令，最后把返回的字符串通过<code>String#split</code>方法拆分成了列表。详细解释<a href="http://code.oneapm.com/ruby/2015/07/02/how-to-create-a-gem/" target="_blank" rel="noopener">参考链接</a></p><h5 id="编写代码"><a href="#编写代码" class="headerlink" title="编写代码"></a>编写代码</h5><p>在lib中的<code>mygem.rb</code>中:</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">require</span> <span class="string">"mygem/version"</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">Mygem</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">self</span>.<span class="title">hello</span></span></span><br><span class="line">    puts <span class="string">"hello world"</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h5 id="编译Gem"><a href="#编译Gem" class="headerlink" title="编译Gem"></a>编译Gem</h5><p>使用<a href="https://github.com/ruby/rake" target="_blank" rel="noopener">Rake</a>命令build Gem。Rake意思为Ruby Make，一个用ruby开发的代码构建工具。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ rake build</span><br><span class="line">mygem 0.1.0 built to pkg/mygem-0.1.0.gem.</span><br></pre></td></tr></table></figure><p>在pkg目录下的<code>mygem-0.1.0.gem</code>就是生成好的Gem文件，然后在把它安装到Gem的本地目录中去，使用</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ rake install</span><br><span class="line">mygem 0.1.0 built to pkg/mygem-0.1.0.gem.</span><br><span class="line">mygem (0.1.0) installed.</span><br></pre></td></tr></table></figure><p>使用gem命令查看是否安装成功</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ gem list --<span class="built_in">local</span> | grep <span class="string">"mygem"</span></span><br><span class="line">mygem (0.1.0)</span><br></pre></td></tr></table></figure><p>接下来就可以在pry或者irb中使用了</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">require <span class="string">"mygem"</span></span><br><span class="line">=&gt; <span class="literal">true</span></span><br><span class="line">Mygem.hello</span><br><span class="line">=&gt; <span class="string">"hello world"</span></span><br></pre></td></tr></table></figure><p>编写完之后还可以使用<code>rake release</code>发布Gem到rubygems.org</p><p><strong>参考链接</strong></p><ul><li><a href="https://guides.rubygems.org/make-your-own-gem/" target="_blank" rel="noopener">Make Your Own Gem</a></li><li><a href="https://bundler.io/v1.16/guides/creating_gem.html" target="_blank" rel="noopener">How to Create a Ruby Gem With Bundler</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Gem介绍&quot;&gt;&lt;a href=&quot;#Gem介绍&quot; class=&quot;headerlink&quot; title=&quot;Gem介绍&quot;&gt;&lt;/a&gt;Gem介绍&lt;/h3&gt;&lt;p&gt;Gem是Ruby源代码库的打包格式，其内部有以下组件&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;源代码（包括测试和工具代码）&lt;/li
      
    
    </summary>
    
    
      <category term="Ruby" scheme="https://blog.ache.fun/tags/Ruby/"/>
    
  </entry>
  
  <entry>
    <title>《非暴力沟通》读书笔记</title>
    <link href="https://blog.ache.fun/2018/10/28/%E3%80%8A%E9%9D%9E%E6%9A%B4%E5%8A%9B%E6%B2%9F%E9%80%9A%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>https://blog.ache.fun/2018/10/28/《非暴力沟通》读书笔记/</id>
    <published>2018-10-28T08:38:52.000Z</published>
    <updated>2018-10-28T10:38:00.383Z</updated>
    
    <content type="html"><![CDATA[<p>这本书看完之后可以说整个人都是矛盾的，一方面觉得书中的观点有点道理，另一方面为他这种冗余的写作手法感到困惑。因此只花了两周的空余时间快速读过，在这里抛开书中过多的举例说明，记录下其主要的核心观点。</p><h3 id="非暴力沟通的要素"><a href="#非暴力沟通的要素" class="headerlink" title="非暴力沟通的要素"></a>非暴力沟通的要素</h3><ul><li>观察：清楚地表达观察结果，而不判断或评估；</li><li>感受：表达内心的感受，不仅可以促进感情，还可以改善工作；</li><li>需要：感受的来源；</li><li>请求：提出具体的请求，注意区分和命令之间的关系</li></ul><h3 id="“异化”的沟通方式"><a href="#“异化”的沟通方式" class="headerlink" title="“异化”的沟通方式"></a>“异化”的沟通方式</h3><ul><li>道德批判：用自己的价值观或标准来批判别人。忽视了彼此的感受和需要；</li><li>进行比较：比较会蒙蔽对自己和他人的爱意；</li><li>回避责任：使用类似于“不得不”，“你让我”之类的表达方式淡化了个人的责任。一旦意识不到我们是自己的主人，我们就成了危险人物；</li><li>强人所难：命令和要求别人。我们大多数人使用的语言倾向于评判、比较、命令和指责，而不是鼓励我们倾听彼此的感受和需要；</li></ul><h3 id="非暴力沟通四要素注意事项"><a href="#非暴力沟通四要素注意事项" class="headerlink" title="非暴力沟通四要素注意事项"></a>非暴力沟通四要素注意事项</h3><h5 id="1-区分观察和评论"><a href="#1-区分观察和评论" class="headerlink" title="1. 区分观察和评论"></a>1. 区分观察和评论</h5><blockquote><p>印度哲学家克里希那穆提曾说过：“不带评论的观察使人类智力的最高形式”</p></blockquote><p>非暴力沟通的第一个要素是观察。将观察和评论混为一谈，别人就会倾向于听到批评，并反驳我们。非暴力沟通是动态的语言，不主张绝对化的结论。它提倡在特定的时间和情境中进行观察，并清楚地描述观察结果。</p><h5 id="2-区分感受和想法"><a href="#2-区分感受和想法" class="headerlink" title="2. 区分感受和想法"></a>2. 区分感受和想法</h5><p>要区分感受和想法，一是要区分哪些是感受，例如：”被xx“（如被抛弃、被羞辱、被虐待、被拒绝…）、“我认为”，“我觉得”，“得不到支持”等等都是在表达想法。二是要建立感受的词汇库。</p><h5 id="3-需要：感受的根源"><a href="#3-需要：感受的根源" class="headerlink" title="3. 需要：感受的根源"></a>3. 需要：感受的根源</h5><p>非暴力沟通强调，感受的根源在于我们自身。我们的需要和期待，以及对他人言行的看法，导致了我们的感受。</p><p>推荐通过<strong>“我（感到）……因为我……”</strong> 这种表达方式认识感受与自身的关系。</p><p>每个人都有的基本需要包括：自由选择、庆祝、言行一致、滋养身体、玩耍、情意相通、相互依存等等。</p><p>这里作者只是介绍了如何认识感受与自身的关系和表达感受，却没有提及如何处理别人提出的感受。</p><h5 id="4-请求帮助"><a href="#4-请求帮助" class="headerlink" title="4. 请求帮助"></a>4. 请求帮助</h5><p>在表达观察、感受和需要之后、我们请求他人的帮助。以下面的方式提出请求容易得到积极回应</p><ul><li>提出具体的请求</li><li>明确谈话的目的</li><li>请求反馈</li><li>了解他们的反应</li></ul><p>参加集体讨论时，说清楚我们希望得到怎样的反馈，是至关重要的。如果不清楚发言的目的。我们的讨论只是在浪费时间，而无法满足任何人的需要。</p><p><strong>如何区分请求与命令</strong></p><p>请求没有得到满足时，提出请求的人如果批评或指责，那就是命令；如果利用对方的内疚来达到目的，也是命令。</p><h3 id="用全身心倾听"><a href="#用全身心倾听" class="headerlink" title="用全身心倾听"></a>用全身心倾听</h3><p>当他人遭遇不幸时，我们常常急于提建议，安慰，或表达我们的态度和感受。为倾听他人，我们需要先放下自己有的想法和判断，全心全意地体会对方。倾听他人有助于对他人的理解和接纳。非暴力沟通建议我们用疑问句来给予他人反馈，我们的问题可以集中在对他人的观察、感受、需要和请求方面，同时注意在表达时需要具体。</p><p>当我们痛苦得无法倾听他人时，我们需要</p><ul><li>体会自己的感受和需要</li><li>大声的提出请求</li><li>换一个环境</li></ul><h5 id="倾听的力量"><a href="#倾听的力量" class="headerlink" title="倾听的力量"></a>倾听的力量</h5><p>倾听使我们勇于面对自己的弱点。它还可以帮助我们预防潜在的暴力。</p><h3 id="非暴力沟通中的自己"><a href="#非暴力沟通中的自己" class="headerlink" title="非暴力沟通中的自己"></a>非暴力沟通中的自己</h3><p>当我们表现不完美时，我们可以通过体会忧伤和自我宽恕，来看清个人成长的方向，以及避免自我惩罚。评价自己的行为时，我们专注于尚未满足的需要，这样，我们就不再依赖羞愧、内疚、恼怒或沮丧的心理来寻求改变。</p><p>同时，在日常生活中，我们主动根据需要和价值观来选择生活。我们的行为不再是为了履行职责、获得回报、逃避惩罚或避免感到内疚和羞愧。通过深入理解我们行为的动机，并用“选择做”来取代”不得不”。</p><h3 id="充分表达愤怒"><a href="#充分表达愤怒" class="headerlink" title="充分表达愤怒"></a>充分表达愤怒</h3><p>在生气时，批评和指责他人都无法真正传达我们的心声。如果想充分表达愤怒，我们就不能归咎于他人，而把注意力放在自己的感受和需要上。与批评和指责他人相比，直接说出我们的需要更有可能使我们的愿望得到满足。</p><p>表达愤怒的四个步骤是：</p><ol><li>停下来深呼吸。避免采取行动去指责或惩罚对方。</li><li>想一想什么想法使我们生气了。</li><li>体会自己的需要</li><li>表达我们的感受和尚未满足的需要</li></ol><h3 id="表达感激"><a href="#表达感激" class="headerlink" title="表达感激"></a>表达感激</h3><ol><li>对我们有益的行为</li><li>我们的哪些需要得到了满足</li><li>我们的需要得到了满足后，我们是什么样的心情</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>书中的观点给我给我带来了意识层面的冲击，认识到了自己之前沟通方式的不足，不过在实际生活中感觉应用的人并不是很多。如果实践起来的话，前期可能需要极大的精力成本，希望在之后顺利的应用吧！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这本书看完之后可以说整个人都是矛盾的，一方面觉得书中的观点有点道理，另一方面为他这种冗余的写作手法感到困惑。因此只花了两周的空余时间快速读过，在这里抛开书中过多的举例说明，记录下其主要的核心观点。&lt;/p&gt;
&lt;h3 id=&quot;非暴力沟通的要素&quot;&gt;&lt;a href=&quot;#非暴力沟通的
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://blog.ache.fun/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Ruby Minitest 源码分析</title>
    <link href="https://blog.ache.fun/2018/10/21/Ruby-Minitest-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>https://blog.ache.fun/2018/10/21/Ruby-Minitest-源码分析/</id>
    <published>2018-10-21T03:27:44.000Z</published>
    <updated>2018-10-22T01:16:25.221Z</updated>
    
    <content type="html"><![CDATA[<p>Minitest是Ruby中最简单的测试框架，和<a href="https://github.com/rspec/rspec" target="_blank" rel="noopener">RSpec</a>相比，语法简单，容易上手。上周使用的时候被它能够自动执行测试类中测试方法的特性所吸引，最近又在学习元编程，感觉可以学习下它的实现思路，便一头扎入源码的阅读中。在这里记录下源码分析的过程：</p><h3 id="获取当前测试类"><a href="#获取当前测试类" class="headerlink" title="获取当前测试类"></a>获取当前测试类</h3><p>从测试实例开始</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cat_test.rb</span></span><br><span class="line"><span class="keyword">require</span> <span class="string">"minitest/autorun"</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestCat</span> &lt; Minitest::Test</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setup</span></span></span><br><span class="line">        @cat = Cat.new</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_meow</span></span></span><br><span class="line">        <span class="comment"># 相等</span></span><br><span class="line">        assert_equal <span class="string">"Meow~!"</span>, @cat.meow</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>首先，Minitest要执行到声明的测试类，在Minitest中要获取到声明的测试类才能执行其中的方法，那么在Minitest是如何获取到声明的类呢？</p><p>在Minitest中的<code>minitest.rb</code>中</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># minitest.rb </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Runnable</span> <span class="comment"># re-open</span></span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">self</span>.<span class="title">inherited</span> <span class="title">klass</span> <span class="comment"># :nodoc:</span></span></span><br><span class="line">     <span class="keyword">self</span>.runnables &lt;&lt; klass</span><br><span class="line">     <span class="keyword">super</span></span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line"> <span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>在minitest.rb中的Runnable类中有个<a href="https://ruby-doc.org/core-2.5.1/Class.html#method-i-inherited" target="_blank" rel="noopener">inherited</a>方法，这个方法是当前类的子类或者当前类创建时的回调，在<code>test.rb</code>中的<code>Test</code>类继承自Runnable这个类，而在测试用例的使用中测试类又继承自<code>Test</code>类，所以在每次写测试用例的时候在Test中就能获取到声明的子类。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> &lt; Runnable</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="在测试类声明之后示例化"><a href="#在测试类声明之后示例化" class="headerlink" title="在测试类声明之后示例化"></a>在测试类声明之后示例化</h3><p>通过inherited方法，minitest可以获取到我们声明的测试类了，但我们的声明在<code>require &#39;mintiest/autorun&#39;</code>之后，在测试文件声明测试类之后就结束运行了。那minitest是如何把声明的测试类实例化并调用其方法了呢？在<code>autorun.rb</code>中的<code>Minitest.autorun</code>中，有几个<a href="https://ruby-doc.org/core-2.5.3/Kernel.html#method-i-at_exit" target="_blank" rel="noopener">at_exit</a>方法，它被包含在<code>Kernel</code>模块中。它可以把传递给它的块转换为Proc对象，并在程序退出的时候调用。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># minitest.rb  </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">self</span>.<span class="title">autorun</span></span></span><br><span class="line">    at_exit &#123;</span><br><span class="line">      <span class="keyword">next</span> <span class="keyword">if</span> $! <span class="keyword">and</span> <span class="keyword">not</span> ($!.kind_of? SystemExit <span class="keyword">and</span> $!.success?)</span><br><span class="line"></span><br><span class="line">      exit_code = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">      at_exit &#123;</span><br><span class="line">        @@after_run.reverse_each(&amp;<span class="symbol">:call</span>)</span><br><span class="line">        exit exit_code <span class="params">||</span> <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      exit_code = Minitest.run ARGV</span><br><span class="line">    &#125; <span class="keyword">unless</span> @@installed_at_exit</span><br><span class="line">    @@installed_at_exit = <span class="literal">true</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="找到测试类声明的方法"><a href="#找到测试类声明的方法" class="headerlink" title="找到测试类声明的方法"></a>找到测试类声明的方法</h3><p>找到类中的声明方法在</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># minitest.rb</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Runnable</span></span></span><br><span class="line">    ...</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">self</span>.<span class="title">methods_matching</span> <span class="title">re</span></span></span><br><span class="line">      public_instance_methods(<span class="literal">true</span>).grep(re).map(&amp;<span class="symbol">:to_s</span>)</span><br><span class="line"> <span class="keyword">end</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>查找方法</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># test.rb</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line">    ...</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">self</span>.<span class="title">runnable_methods</span></span></span><br><span class="line">      methods = methods_matching(<span class="regexp">/^test_/</span>)</span><br><span class="line">      ...</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    ...</span><br><span class="line"> <span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>在获取可运行的方法使用了Ruby 类的<a href="https://ruby-doc.org/core-2.5.1/Module.html#method-i-public_instance_methods" target="_blank" rel="noopener">public_instance_methods</a>方法，这个方法返回在mod中定义的公共实例方法的列表。如果可选参数为false，则不包括任何祖先的方法。可以看到这里只匹配测试类中的以<code>test_</code>开头的方法。</p><h3 id="运行测试方法"><a href="#运行测试方法" class="headerlink" title="运行测试方法"></a>运行测试方法</h3><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># minitest.rb</span></span><br><span class="line">filtered_methods.each <span class="keyword">do</span> <span class="params">|method_name|</span></span><br><span class="line">  run_one_method <span class="keyword">self</span>, method_name, reporter</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>在做了一些额外的筛选之后，运行<code>run_one_method</code></p><p>这最终调用了Minitest : : Test上的运行实例方法:</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">capture_exceptions <span class="keyword">do</span></span><br><span class="line">  before_setup; setup; after_setup</span><br><span class="line">  <span class="keyword">self</span>.send <span class="keyword">self</span>.name</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在Minitest中使用了大量的Ruby元编程特性，这些特性如果熟练灵活运用可以创造很多新奇的东西。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Minitest是Ruby中最简单的测试框架，和&lt;a href=&quot;https://github.com/rspec/rspec&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;RSpec&lt;/a&gt;相比，语法简单，容易上手。上周使用的时候被它能够自动执行测试类中
      
    
    </summary>
    
    
      <category term="Ruby" scheme="https://blog.ache.fun/tags/Ruby/"/>
    
  </entry>
  
  <entry>
    <title>Ruby 测试工具——Minitest</title>
    <link href="https://blog.ache.fun/2018/10/14/Ruby-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7%E2%80%94%E2%80%94Minitest/"/>
    <id>https://blog.ache.fun/2018/10/14/Ruby-测试工具——Minitest/</id>
    <published>2018-10-14T12:19:57.000Z</published>
    <updated>2018-10-14T15:44:36.500Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/seattlerb/minitest" target="_blank" rel="noopener">minitest</a>是一套Ruby的测试工具，支持<a href="https://zh.wikipedia.org/wiki/%E6%B5%8B%E8%AF%95%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91" target="_blank" rel="noopener">TDD</a>、<a href="https://zh.wikipedia.org/wiki/%E8%A1%8C%E4%B8%BA%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91" target="_blank" rel="noopener">BDD</a>、Mock和基准测试。minitest使用最简单的Ruby语法，没有自己定义一套。因此上手非常简单。</p><p>和另一个测试框架<code>rspec</code>相比引用官方文档的一句话</p><blockquote><p>minitest doesn’t reinvent anything that ruby already provides, like: classes, modules, inheritance, methods. This means you only have to learn ruby to use minitest and all of your regular OO practices like extract-method refactorings still apply.</p></blockquote><h3 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h3><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cat.rb</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span></span></span><br><span class="line">    TOYS = [</span><br><span class="line">        <span class="string">"sofa"</span>,</span><br><span class="line">        <span class="string">"teddy"</span></span><br><span class="line">    ]  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">meow</span></span></span><br><span class="line">      <span class="string">"Meow~!"</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">scratch</span><span class="params">(target)</span></span></span><br><span class="line">      <span class="string">"YES!"</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">favorite_toy</span><span class="params">()</span></span></span><br><span class="line">        <span class="string">"teddy"</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"> <span class="keyword">end</span></span><br></pre></td></tr></table></figure><h5 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h5><h5 id="minitest风格"><a href="#minitest风格" class="headerlink" title="minitest风格"></a>minitest风格</h5><p>在定义一个以Test开始的类</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">require</span> <span class="string">"minitest/autorun"</span></span><br><span class="line">require_relative <span class="string">"cat"</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestCat</span> &lt; Minitest::Test</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setup</span></span></span><br><span class="line">        @cat = Cat.new</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_meow</span></span></span><br><span class="line">        <span class="comment"># 相等</span></span><br><span class="line">        assert_equal <span class="string">"Meow~!"</span>, @cat.meow</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_toys_is_array</span></span></span><br><span class="line">        <span class="comment"># 断言类型</span></span><br><span class="line">        assert_kind_of Array, Cat::TOYS</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_favorite_toy</span></span></span><br><span class="line">        <span class="comment"># 断言是否包括</span></span><br><span class="line">        assert_includes Cat::TOYS, @cat.favorite_toy</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_toys_empty</span></span></span><br><span class="line">        <span class="comment"># 断言非空，refute是取反的意思</span></span><br><span class="line">        refute_empty Cat::TOYS</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_not_woof</span></span></span><br><span class="line">        <span class="comment"># 断言匹配</span></span><br><span class="line">        refute_match /^woof/i, @cat.meow</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_raises_error</span></span></span><br><span class="line">        <span class="comment"># 测试抛出错误</span></span><br><span class="line">        assert_raises <span class="string">"There is no toy here"</span> <span class="keyword">do</span></span><br><span class="line">            @cat.scratch(<span class="string">"teddy"</span>)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_that_will_be_skipped</span></span></span><br><span class="line">        <span class="comment"># 跳过</span></span><br><span class="line">        skip <span class="string">"test this later"</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h5 id="specs风格"><a href="#specs风格" class="headerlink" title="specs风格"></a>specs风格</h5><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">require</span> <span class="string">"minitest/autorun"</span></span><br><span class="line"><span class="keyword">require</span> <span class="string">"minitest/spec"</span></span><br><span class="line">require_relative <span class="string">"cat"</span></span><br><span class="line"></span><br><span class="line">describe Cat <span class="keyword">do</span></span><br><span class="line">  before <span class="keyword">do</span></span><br><span class="line">    @cat = Cat.new</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  describe <span class="string">"#meow"</span> <span class="keyword">do</span></span><br><span class="line">    it <span class="string">"must respond meow"</span> <span class="keyword">do</span></span><br><span class="line">      @cat.meow.must_equal <span class="string">"Meow~!"</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">      </span><br><span class="line">    it <span class="string">"predefined toys is array"</span> <span class="keyword">do</span></span><br><span class="line">      @cat.assert_kind_of Array, Cat::TOYS</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">      </span><br><span class="line">    it <span class="string">"test favorite toy"</span> <span class="keyword">do</span></span><br><span class="line">      @cat.assert_includes Cat::TOYS, @cat.favorite_toy</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">      </span><br><span class="line">    it <span class="string">"test toys empty"</span> <span class="keyword">do</span></span><br><span class="line">      @cat.refute_empty Cat::TOYS</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    it <span class="string">"test raises error"</span> <span class="keyword">do</span></span><br><span class="line">      @cat.assert_raises <span class="string">"There is no toy here"</span> <span class="keyword">do</span></span><br><span class="line">            @cat.scratch(<span class="string">"teddy"</span>)</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">      </span><br><span class="line">    it <span class="string">"test that will be skipped"</span> <span class="keyword">do</span></span><br><span class="line">      skip <span class="string">"test this later"</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p><code>Minitest::Test</code>提供了几个生命周期的钩子，分别是</p><ul><li><p>before_setup</p></li><li><p>setup</p></li><li><p>after_setup</p></li><li><p>before_teardown</p></li><li><p>teardown</p></li><li><p>after_teardown</p></li></ul><p>一般开发只用<code>setup</code>和<code>teardown</code>就够用了，几个<code>before_*</code>和<code>after_*</code>是用于minitest扩展的。</p><p>以上只列出了常用的几个assertion，查看所有的查阅<a href="http://docs.seattlerb.org/minitest/Minitest/Assertions.html" target="_blank" rel="noopener">Minitest Assertions API</a></p><p>此外，MiniTest还提供了<code>Benchmarks</code>和<code>Mocks</code>，后续更新……</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://github.com/seattlerb/minitest&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;minitest&lt;/a&gt;是一套Ruby的测试工具，支持&lt;a href=&quot;https://zh.wikipedia.o
      
    
    </summary>
    
    
      <category term="Ruby" scheme="https://blog.ache.fun/tags/Ruby/"/>
    
  </entry>
  
  <entry>
    <title>Ruby可调用对象</title>
    <link href="https://blog.ache.fun/2018/10/07/Ruby%E5%8F%AF%E8%B0%83%E7%94%A8%E5%AF%B9%E8%B1%A1/"/>
    <id>https://blog.ache.fun/2018/10/07/Ruby可调用对象/</id>
    <published>2018-10-07T15:27:50.000Z</published>
    <updated>2018-10-08T02:19:20.832Z</updated>
    
    <content type="html"><![CDATA[<p>Ruby中，用来打包代码块的四种方法分别是</p><ul><li>代码块</li><li>使用proc，proc是由代码块转换来的对象</li><li>使用lambda，它是proc的变种。</li><li>使用方法</li></ul><h3 id="Proc对象"><a href="#Proc对象" class="headerlink" title="Proc对象"></a>Proc对象</h3><p>Ruby中绝大多数东西都是对象。但是代码块不是。如果需要存储一个块供以后执行，就需要一个Proc对象。</p><p>Proc是由块转换来的对象。可以把代码块传给Proc.new方法创建一个Proc。以后就可以用<code>Proc#call</code>方法来执行这个由代码块转换而来的对象：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">inc = Proc.new &#123;<span class="params">|x|</span> x + <span class="number">1</span> &#125;</span><br><span class="line"><span class="comment"># ......</span></span><br><span class="line">inc.call(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>以上称为<strong>延迟执行</strong>(Deferred Evaluation)。</p><p>使用lambda创建Proc</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dec = lambda &#123;<span class="params">|x|</span> x + <span class="number">1</span> &#125;</span><br><span class="line">dec.<span class="keyword">class</span></span><br><span class="line">dec.call(<span class="number">2</span>)<span class="comment"># =&gt; 3</span></span><br></pre></td></tr></table></figure><p>带刺的lambda （stabby lambda）操作符创建lambda：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p =&gt; -&gt;(x) &#123; x + <span class="number">1</span> &#125;</span><br><span class="line"><span class="comment"># 以上代码等同于</span></span><br><span class="line">p = lambda &#123; <span class="params">|x|</span> x + <span class="number">1</span> &#125;</span><br></pre></td></tr></table></figure><h5 id="amp-操作符"><a href="#amp-操作符" class="headerlink" title="&amp;操作符"></a>&amp;操作符</h5><p>代码块就像是方法额外的匿名参数。绝大多数情况下，在方法中可以通过yield语句直接执行一个代码块。但在下面两种情况下，yield就力不从心了：</p><ul><li><p>把代码块传递给另外一个方法（甚至代码块）</p></li><li><p>把代码块转换成proc</p><p>要将代码块附加到一个绑定上，可以给这个方法添加一个特殊的参数，这个参数必须是参数列表中的最后一个，且以<code>&amp;</code>开头：</p></li></ul><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">math</span><span class="params">(a, b)</span></span></span><br><span class="line">    <span class="keyword">yield</span>(a, b)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">do_math</span><span class="params">(a, b, &amp;operation)</span></span></span><br><span class="line">    math(a, b &amp;operation)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">do_math(<span class="number">2</span>, <span class="number">3</span>) &#123;<span class="params">|x, y|</span> x * y&#125;<span class="comment"># =&gt; 6</span></span><br></pre></td></tr></table></figure><p>如果在调用<code>do_math</code>方法时没有附加代码块，那么<code>&amp;operation</code>参数将被赋值为<code>nil</code>，这样math方法中的yield操作就会失败。</p><p>在上面的代码中引用了operation，就已经拥有了一个Proc对象。&amp;对象操作符的含义是：<strong>对已有的Proc对象当成代码块来使用</strong> 去掉&amp;操作符，就能再次得到一个Proc对象：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_method</span><span class="params">(&amp;the_proc)</span></span></span><br><span class="line">    the_proc</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">p = my_method &#123;<span class="params">|name|</span> <span class="string">"Hello, <span class="subst">#&#123;name&#125;</span>!"</span> &#125;</span><br><span class="line">p.<span class="keyword">class</span> <span class="comment"># =&gt; Proc</span></span><br><span class="line">p.call(<span class="string">"Bill"</span>)    <span class="comment"># =&gt; "Hello, Bill!</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果想把Proc转换成代码块</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_method</span><span class="params">(greeting)</span></span></span><br><span class="line">    <span class="string">"<span class="subst">#&#123;greeting&#125;</span>, <span class="subst">#&#123;<span class="keyword">yield</span>&#125;</span>!"</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">my_proc = proc &#123; <span class="string">"Bill"</span> &#125;</span><br><span class="line">my_method&#123;<span class="string">"Hello"</span>, &amp;my_proc&#125;</span><br><span class="line"><span class="comment"># 调用my_method方法时，&amp;操作符会把my_proc转换成代码块，再把代码块传给这个方法。</span></span><br></pre></td></tr></table></figure><h3 id="Proc与Lambda对比"><a href="#Proc与Lambda对比" class="headerlink" title="Proc与Lambda对比"></a>Proc与Lambda对比</h3><p>用lambda方法创建的Proc与其他方式创建的Proc有一些细微却重要的差别。用lambda方法创建的Proc称为lambda，而用其他方式创建的则称为proc。</p><p>可以使用<code>Proc#lambda?</code>方法检测Proc是不是lambda。</p><p><code>Proc</code>和<code>lambda</code>的重要差别有两个。第一个与return关键字有关，另一个则与参数校验有关。</p><h5 id="Proc、Lambda和return"><a href="#Proc、Lambda和return" class="headerlink" title="Proc、Lambda和return"></a>Proc、Lambda和return</h5><p>在lambda中，return仅仅表示从这个lambda中返回</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">double</span><span class="params">(callable_object)</span></span></span><br><span class="line">    callable_object.call * <span class="number">2</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">l = lambda &#123; <span class="keyword">return</span> <span class="number">10</span> &#125;</span><br><span class="line">double(l)        <span class="comment"># =&gt; 20</span></span><br></pre></td></tr></table></figure><p>在proc中，return的行为则有所不同。它不是从proc中返回，而是从定义proc的作用域中返回：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">another_double</span></span></span><br><span class="line">    p = Proc.new&#123; <span class="keyword">return</span> <span class="number">10</span> &#125;</span><br><span class="line">    result = p.call</span><br><span class="line">    <span class="keyword">return</span> result * <span class="number">2</span>. <span class="comment"># 不能达到的代码</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">another_double<span class="comment"># =&gt; 10</span></span><br></pre></td></tr></table></figure><h5 id="Proc、Lambda和参数数量"><a href="#Proc、Lambda和参数数量" class="headerlink" title="Proc、Lambda和参数数量"></a>Proc、Lambda和参数数量</h5><p>在参数问题上，lambda的适应能力比proc(以及普通代码块)差。如果调用lambda时参数数量不对，就会抛出<code>ArgumentError</code>错误；而proc则会把传来的参数调整成自己期望的参数形式：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p = Proc.new &#123;<span class="params">|a, b|</span> &#123;a, b&#125;&#125;</span><br><span class="line">p.call(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)<span class="comment"># =&gt; [1, 2]</span></span><br><span class="line">p.call(<span class="number">1</span>)<span class="comment"># =&gt; [1, nil]</span></span><br></pre></td></tr></table></figure><p>如果参数比期望的要多，则proc会忽略多余的参数；如果参数数量不足，对于未指定的参数，proc会赋值为nil.</p><h5 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h5><p>整体而言，lambda更直观，以为它更像一个方法。它对参数数量要求严格，而且在调用return时确实只是从代码中返回。因此，lambda应作为第一选择，除非需要使用proc的某些特殊功能。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Ruby中，用来打包代码块的四种方法分别是&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;代码块&lt;/li&gt;
&lt;li&gt;使用proc，proc是由代码块转换来的对象&lt;/li&gt;
&lt;li&gt;使用lambda，它是proc的变种。&lt;/li&gt;
&lt;li&gt;使用方法&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;Proc
      
    
    </summary>
    
    
      <category term="Ruby" scheme="https://blog.ache.fun/tags/Ruby/"/>
    
  </entry>
  
  <entry>
    <title>Ruby中的类定义</title>
    <link href="https://blog.ache.fun/2018/10/02/Ruby%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%AE%9A%E4%B9%89/"/>
    <id>https://blog.ache.fun/2018/10/02/Ruby中的类定义/</id>
    <published>2018-10-02T05:27:51.000Z</published>
    <updated>2018-10-07T08:22:28.755Z</updated>
    
    <content type="html"><![CDATA[<p>最近因工作需要学习Ruby，被Ruby的优雅和灵活所吸引，阅读《Ruby元编程》的时候更是酣畅淋漓，想吃了炫迈一样，第五章类定义是本书中的核心部分，在这里记录下相本章相关笔记。</p><h3 id="类定义"><a href="#类定义" class="headerlink" title="类定义"></a>类定义</h3><h5 id="类定义-1"><a href="#类定义-1" class="headerlink" title="类定义"></a>类定义</h5><p>定义类不止是定义方法。其实，可以在类定义中放入任何代码</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span><br><span class="line">    puts <span class="string">"Hello"</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">&lt; Hello</span><br></pre></td></tr></table></figure><p>就像方法和块一样，类定义也会返回最后一条语句的值</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">result = <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span><br><span class="line">    <span class="keyword">self</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">result <span class="comment"># =&gt; MyClass</span></span><br></pre></td></tr></table></figure><p>定义类（或模块）时，类本身充当当前对象self的角色。类和模块也是对象，所以类也可以充当self。</p><h5 id="当前类"><a href="#当前类" class="headerlink" title="当前类"></a>当前类</h5><ul><li><p>Ruby解释器总是追踪当前类(或模块)的引用。所有使用<code>def</code>定义的方法成为当前类的实例方法。</p></li><li><p>在类定义中，当前类就是self——正在定义的类</p></li><li><p>可以使用class_eval（或module_eval）方法打开一个已存在的类的引用</p></li></ul><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_method_to</span><span class="params">(a_class)</span></span></span><br><span class="line">    a_class.class_eval <span class="keyword">do</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">m</span>;</span> <span class="string">'Hello!'</span>; <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">add_method_to String</span><br><span class="line"></span><br><span class="line"><span class="string">"abc"</span>.m</span><br></pre></td></tr></table></figure><p>instance_eval和class_eval方法的选择：通常使用instalce_eval/class_eval方法打开非类的对象；用class_eval方法打开类的定义，然后用def定义方法。如果打开的对象也是类（或模块），只修改self而且并不关心它是不是一个类，那么instance_eval就很好；如果使用<strong>打开类</strong>技巧修改类，使用<code>class_eval</code>方法更好。</p><h5 id="类实例变量"><a href="#类实例变量" class="headerlink" title="类实例变量"></a>类实例变量</h5><p>类的实例变量不同于类的对象的实例变量。例如</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span><br><span class="line">    <span class="comment"># 这个my_var 定义于MyClass充当self的时刻，它是MyClass的实例变量，也就是类实例变量。</span></span><br><span class="line">    @my_var = <span class="number">1</span></span><br><span class="line">    <span class="comment"># 同样类实例变量</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">self</span>.<span class="title">read</span>;</span> @my_var; <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">     <span class="comment"># 这个my_var 定义于obj充当self的时刻，它是obj的实例变量</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">write</span>;</span> @my_var = <span class="number">2</span>; <span class="keyword">end</span> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">read</span>;</span> @my_var; <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">obj = MyClass.new</span><br><span class="line">obj.read  <span class="comment"># =&gt; nil</span></span><br><span class="line">obj.write</span><br><span class="line">obj.read <span class="comment"># =&gt; 2</span></span><br><span class="line">MyClass.read <span class="comment"># =&gt; 1</span></span><br></pre></td></tr></table></figure><h3 id="单件方法"><a href="#单件方法" class="headerlink" title="单件方法"></a>单件方法</h3><h5 id="使用单件方法"><a href="#使用单件方法" class="headerlink" title="使用单件方法"></a>使用单件方法</h5><p>Ruby允许给单个对象增加一个方法。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">str = <span class="string">"just a regular string"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">str</span>.<span class="title">title?</span></span></span><br><span class="line">    <span class="keyword">self</span>.upcase == <span class="keyword">self</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">str.title?    <span class="comment"># =&gt; fasle</span></span><br><span class="line">str.methods.grep(<span class="regexp">/title?/</span>)<span class="comment"># =&gt; [:title?]</span></span><br><span class="line">str.singleton_methods       <span class="comment"># =&gt; [:title?]</span></span><br></pre></td></tr></table></figure><p>只对单个对象生效的方法称为<strong>单件方法</strong>(Singleton Method)。可以直接 <code>def obj.singleton_method</code>来定义单件方法，也可以使用<code>Object#define_singleton_method</code>方法来定义。</p><h5 id="类方法的真相"><a href="#类方法的真相" class="headerlink" title="类方法的真相"></a>类方法的真相</h5><p>类也是对象，而类名只是常量。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 由变量引用的对象上调用方法</span></span><br><span class="line">an_object.a_method</span><br><span class="line"></span><br><span class="line"><span class="comment"># 一个由常量引用的对象（也是一个类）上调用方法。和上面语法完全一样</span></span><br><span class="line">AClass.a_class_method</span><br></pre></td></tr></table></figure><p><strong>类方法的实质上是一个类的单件方法</strong></p><h5 id="类宏"><a href="#类宏" class="headerlink" title="类宏"></a>类宏</h5><p>Ruby对象没有属性。如果要实现类似属性的东西，需要定义两个方法。不过Module类中定义了三个访问器：<code>attr_reader</code>、<code>attr_writer</code>和<code>attr_accessor</code>，像这样的方法称为<strong>类宏</strong>(Class Macro)。类宏看起来很像关键字，但是它们只是普通的方法，只不过可以用在类定义里。</p><h3 id="单件类"><a href="#单件类" class="headerlink" title="单件类"></a>单件类</h3><p>Ruby查找方法时先向右一步进入接收者的类，然后在向上查找，那么单件方法存放在哪里呢？</p><p>向对象询问它的类时，并非直接到实例它的类，而是一个对象特有的隐藏类。这个类称为该对象的<strong>单件类</strong>。</p><p><code>Object#class</code>会把单件类隐藏起来。Ruby有一种特殊的基于class的关键字的语法，可以进入该单件类的作用域：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> &lt;&lt; an_object</span></span><br><span class="line">    <span class="comment"># ......</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>还可以通过<code>Object#singleton_class</code>方法来获得单件类的引用：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"abc"</span>.singleton_class <span class="comment"># =&gt; #&lt;Class:#&lt;String:0x331df0&gt;&gt;</span></span><br></pre></td></tr></table></figure><p>单件类也是类，是特殊的类。用<code>Object#singleton_class</code>方法或<code>class&lt;&lt; obj</code>语法获得它。同时，每个单件类只有一个实例，而且不能被继承。<strong>单件类是一个对象的单件方法的存活的地方</strong>。</p><p><strong>Ruby对象模型的七条规则</strong></p><ol><li>只有一种对象——要么是普通对象，要么是模块。</li><li>只有一种模块——可以是一个普通模块、一个类或者一个单件类。</li><li>只用一种方法，它存在于一个模块中——通常是一个类中。</li><li>每个对象（包括类）都有自己“真正的类”——要么是一个普通类，要么是一个单件类。</li><li>除了<code>BasicObject</code>类没有超类外，每个类有且只有一个祖先——要么是一个类，要么是一个模块。这意味着任何类只有一条向上的、直到<code>BasicObject</code>的祖先链。</li><li>一个对象的单件类的超类是这个对象的类；一个类的单件类的超类是这个类的超类的单件类。</li><li>调用一个方法时，Ruby先向右一步进入接收者真正的类，然后向上进入祖先链，这就是Ruby查找方法的方式。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近因工作需要学习Ruby，被Ruby的优雅和灵活所吸引，阅读《Ruby元编程》的时候更是酣畅淋漓，想吃了炫迈一样，第五章类定义是本书中的核心部分，在这里记录下相本章相关笔记。&lt;/p&gt;
&lt;h3 id=&quot;类定义&quot;&gt;&lt;a href=&quot;#类定义&quot; class=&quot;headerlin
      
    
    </summary>
    
    
      <category term="Ruby" scheme="https://blog.ache.fun/tags/Ruby/"/>
    
  </entry>
  
  <entry>
    <title>Ruby 处理Xml</title>
    <link href="https://blog.ache.fun/2018/09/20/Ruby-%E5%A4%84%E7%90%86Xml/"/>
    <id>https://blog.ache.fun/2018/09/20/Ruby-处理Xml/</id>
    <published>2018-09-20T01:22:36.000Z</published>
    <updated>2018-09-25T02:27:45.930Z</updated>
    
    <content type="html"><![CDATA[<p>Ruby处理Xml主要使用内置的库<a href="https://ruby-doc.org/stdlib-2.1.2/libdoc/rexml/rdoc/REXML/Document.html" target="_blank" rel="noopener"><code>REXML</code></a>，它提供了两种解析方式<code>tree parsing</code>和<code>stream parsing</code></p><h6 id="实例XML代码，games-xml"><a href="#实例XML代码，games-xml" class="headerlink" title="实例XML代码，games.xml"></a>实例XML代码，games.xml</h6><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">collection</span> <span class="attr">id</span>=<span class="string">"test"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">game</span> <span class="attr">title</span>=<span class="string">"The Legend of Zelda: Breath of the Wild"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">company</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>Nintendo<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">location</span>&gt;</span>Japanese<span class="tag">&lt;/<span class="name">location</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">company</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">platform</span>&gt;</span>NS<span class="tag">&lt;/<span class="name">platform</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">platform</span>&gt;</span>WiiU<span class="tag">&lt;/<span class="name">platform</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pubdate</span>&gt;</span>2017<span class="tag">&lt;/<span class="name">pubdate</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">game</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">game</span> <span class="attr">title</span>=<span class="string">"PUBG"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">company</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>PUBG Corporation<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">location</span>&gt;</span>Korea<span class="tag">&lt;/<span class="name">location</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">company</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">platform</span>&gt;</span>PC<span class="tag">&lt;/<span class="name">platform</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">platform</span>&gt;</span>Xbox one<span class="tag">&lt;/<span class="name">platform</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pubdate</span>&gt;</span>2017<span class="tag">&lt;/<span class="name">pubdate</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">game</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="在Ruby中使用tree-parsing-API打开文件"><a href="#在Ruby中使用tree-parsing-API打开文件" class="headerlink" title="在Ruby中使用tree parsing API打开文件"></a>在Ruby中使用tree parsing API打开文件</h5><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">require</span> <span class="string">'rexml/document'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span> REXML</span><br><span class="line"></span><br><span class="line">file = File.new(<span class="string">"games.xml"</span>)</span><br><span class="line"></span><br><span class="line">doc = Document.new(file)</span><br><span class="line"></span><br><span class="line">puts doc</span><br></pre></td></tr></table></figure><p><code>Document.new</code>方法传入的参数必须是 <code>Document</code>，<code>IO</code>, 或字符串，这里的<code>Document</code>官方文档指的是<code>REXML</code>的<code>Document</code>但经测试生成的新的doc为空，不知是否为Ruby的<code>Here Document</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">rb(main):001:0&gt; require 'rexml/document'</span><br><span class="line">=&gt; true</span><br><span class="line">irb(main):002:0&gt; include REXML</span><br><span class="line">=&gt; Object</span><br><span class="line">irb(main):003:0&gt; doc = Document.new(File.new("games.xml"))</span><br><span class="line">=&gt; &lt;UNDEFINED&gt; ... &lt;/&gt;</span><br><span class="line"></span><br><span class="line">irb(main):004:0&gt; puts doc</span><br><span class="line">&lt;?xml version='1.0' encoding='UTF-8'?&gt;</span><br><span class="line">&lt;collection id='test'&gt;</span><br><span class="line">    &lt;game title='The Legend of Zelda: Breath of the Wild'&gt;</span><br><span class="line">        &lt;company&gt;</span><br><span class="line">            &lt;name&gt;Nintendo&lt;/name&gt;</span><br><span class="line">            &lt;location&gt;Japanese&lt;/location&gt;</span><br><span class="line">        &lt;/company&gt;</span><br><span class="line">        &lt;platform&gt;NS&lt;/platform&gt;</span><br><span class="line">        &lt;platform&gt;WiiU&lt;/platform&gt;</span><br><span class="line">        &lt;pubdate&gt;2017&lt;/pubdate&gt;</span><br><span class="line">    &lt;/game&gt;</span><br><span class="line">    &lt;game title='PUBG'&gt;</span><br><span class="line">        &lt;company&gt;</span><br><span class="line">            &lt;name&gt;PUBG Corporation&lt;/name&gt;</span><br><span class="line">            &lt;location&gt;Korea&lt;/location&gt;</span><br><span class="line">        &lt;/company&gt;</span><br><span class="line">        &lt;platform&gt;PC&lt;/platform&gt;</span><br><span class="line">        &lt;platform&gt;Xbox one&lt;/platform&gt;</span><br><span class="line">        &lt;pubdate&gt;2017&lt;/pubdate&gt;</span><br><span class="line">    &lt;/game&gt;</span><br><span class="line">&lt;/collection&gt;</span><br><span class="line">=&gt; nil</span><br><span class="line"></span><br><span class="line">irb(main):005:0&gt; doc2 = Document.new(doc)</span><br><span class="line">=&gt; &lt;/&gt;</span><br><span class="line"></span><br><span class="line">irb(main):006:0&gt; puts doc2</span><br><span class="line">=&gt; nil</span><br></pre></td></tr></table></figure><h5 id="访问元素和属性"><a href="#访问元素和属性" class="headerlink" title="访问元素和属性"></a>访问元素和属性</h5><p>方便调试，使用<code>irb</code>工具来访问元素</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> irb</span><br><span class="line"><span class="meta">&gt;</span>&gt; require 'rexml/document'</span><br><span class="line">=&gt; true</span><br><span class="line"><span class="meta">&gt;</span>&gt; include REXML</span><br><span class="line">=&gt; Object</span><br><span class="line"><span class="meta">&gt;</span>&gt; doc = Document.new(File.new("games.xml"))</span><br><span class="line">=&gt; &lt;UNDEFINED&gt; ... &lt;/&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;</span>&gt; root = doc.root</span><br><span class="line">=&gt; &lt;collection id='test'&gt; ... &lt;/&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;</span>&gt; root.class</span><br><span class="line">=&gt; REXML::Element</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;</span>&gt; root.attributes['id']</span><br><span class="line">=&gt; "test"</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;</span>&gt; puts root.elements[1].elements["company"]</span><br><span class="line">&lt;company&gt;</span><br><span class="line">            &lt;name&gt;Nintendo&lt;/name&gt;</span><br><span class="line">            &lt;location&gt;Japanese&lt;/location&gt;</span><br><span class="line">        &lt;/company&gt;</span><br><span class="line">=&gt; nil</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;</span>&gt; puts root.elements["game[1]/company"]</span><br><span class="line">&lt;company&gt;</span><br><span class="line">            &lt;name&gt;Nintendo&lt;/name&gt;</span><br><span class="line">            &lt;location&gt;Japanese&lt;/location&gt;</span><br><span class="line">        &lt;/company&gt;</span><br><span class="line">=&gt; nil</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;</span>&gt; puts root.elements["game[@title='PUBG']"]</span><br><span class="line">&lt;game title='PUBG'&gt;</span><br><span class="line">        &lt;company&gt;</span><br><span class="line">            &lt;name&gt;PUBG Corporation&lt;/name&gt;</span><br><span class="line">            &lt;location&gt;Korea&lt;/location&gt;</span><br><span class="line">        &lt;/company&gt;</span><br><span class="line">        &lt;platform&gt;PC&lt;/platform&gt;</span><br><span class="line">        &lt;platform&gt;Xbox one&lt;/platform&gt;</span><br><span class="line">        &lt;pubdate&gt;2017&lt;/pubdate&gt;</span><br><span class="line">    &lt;/game&gt;</span><br><span class="line">=&gt; nil</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;</span>&gt; root.each_element('//company') &#123;|company| puts company&#125;</span><br><span class="line">&lt;company&gt;</span><br><span class="line">            &lt;name&gt;Nintendo&lt;/name&gt;</span><br><span class="line">            &lt;location&gt;Japanese&lt;/location&gt;</span><br><span class="line">        &lt;/company&gt;</span><br><span class="line">&lt;company&gt;</span><br><span class="line">            &lt;name&gt;PUBG Corporation&lt;/name&gt;</span><br><span class="line">            &lt;location&gt;Korea&lt;/location&gt;</span><br><span class="line">        &lt;/company&gt;</span><br><span class="line">=&gt; [&lt;company&gt; ... &lt;/&gt;, &lt;company&gt; ... &lt;/&gt;]</span><br></pre></td></tr></table></figure><p>首先，使用Document.new()，生成一个<a href="https://ruby-doc.org/stdlib-2.1.2/libdoc/rexml/rdoc/REXML/Document.html" target="_blank" rel="noopener">Document</a>对象，Document.root 返回文档的根元素（<a href="https://ruby-doc.org/stdlib-2.1.2/libdoc/rexml/rdoc/REXML/Element.html" target="_blank" rel="noopener">Element对象</a>），如果此文档没有子元素，则返回nil。<code>Element</code>对象提供了<code>attribute</code>，<code>element</code>的增加、删除和检测、<code>text</code>的添加、子<code>element</code>的遍历等等，详见其<a href="https://ruby-doc.org/stdlib-2.1.2/libdoc/rexml/rdoc/REXML/Element.html" target="_blank" rel="noopener">API文档</a>。Element.elements 是<a href="https://ruby-doc.org/stdlib-2.1.2/libdoc/rexml/rdoc/REXML/Elements.html" target="_blank" rel="noopener">Elements对象</a>，<code>Elements</code>是为<code>Element</code>提供子元素过滤和Xpath搜索支持，主要使用的是<code>[]</code>方法，<code>[]</code>的参数可以是子元素的索引和<a href="https://www.w3.org/TR/1999/REC-xpath-19991116/" target="_blank" rel="noopener"><code>XPath</code></a>表达式，子元素的索引和<code>XPath</code>的一样是从<strong>1</strong>开始。</p><h5 id="创建和插入元素属性"><a href="#创建和插入元素属性" class="headerlink" title="创建和插入元素属性"></a>创建和插入元素属性</h5><p>创建一个空白文档，并添加元素和属性</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">irb(main):001:0&gt; require 'rexml/document'</span><br><span class="line">=&gt; true</span><br><span class="line">irb(main):002:0&gt; include REXML</span><br><span class="line">=&gt; Object</span><br><span class="line">irb(main):003:0&gt; doc2 = Document.new</span><br><span class="line">=&gt; &lt;UNDEFINED/&gt;</span><br><span class="line"></span><br><span class="line">irb(main):004:0&gt; doc2.class</span><br><span class="line">=&gt; REXML::Document</span><br><span class="line"></span><br><span class="line">irb(main):005:0&gt; doc2.add_element("collection", &#123;"id"=&gt; "test"&#125;)</span><br><span class="line">=&gt; &lt;collection id='test'/&gt;</span><br><span class="line"></span><br><span class="line">irb(main):006:0&gt; doc2.root.add_element("game")</span><br><span class="line">=&gt; &lt;game/&gt;</span><br><span class="line"></span><br><span class="line">irb(main):007:0&gt; game = doc2.root.elements[1]</span><br><span class="line">=&gt; &lt;game/&gt;</span><br><span class="line"></span><br><span class="line">irb(main):008:0&gt; company = Element.new("company")</span><br><span class="line">=&gt; &lt;company/&gt;</span><br><span class="line"></span><br><span class="line">irb(main):009:0&gt; company.add_element("name")</span><br><span class="line">=&gt; &lt;name/&gt;</span><br><span class="line"></span><br><span class="line">irb(main):010:0&gt; company.elements["name"].text = "Riot Games"</span><br><span class="line">=&gt; "Riot Games"</span><br><span class="line"></span><br><span class="line">irb(main):011:0&gt; company.add_element("location")</span><br><span class="line">=&gt; &lt;location/&gt;</span><br><span class="line"></span><br><span class="line">irb(main):012:0&gt; company.elements["location"].text = "America"</span><br><span class="line">=&gt; "America"</span><br><span class="line"></span><br><span class="line">irb(main):013:0&gt; game.elements &lt;&lt; company</span><br><span class="line">=&gt; &lt;company&gt; ... &lt;/&gt;</span><br><span class="line"></span><br><span class="line">irb(main):014:0&gt; platform = Element.new("platform")</span><br><span class="line">=&gt; &lt;platform/&gt;</span><br><span class="line"></span><br><span class="line">irb(main):015:0&gt; platform.text = "Microsoft Windows"</span><br><span class="line">=&gt; "Microsoft Windows"</span><br><span class="line"></span><br><span class="line">irb(main):016:0&gt; game.elements &lt;&lt; platform</span><br><span class="line">=&gt; &lt;platform&gt; ... &lt;/&gt;</span><br><span class="line"></span><br><span class="line">irb(main):018:0&gt; game.elements &lt;&lt; Element.new("pubdate")</span><br><span class="line">=&gt; &lt;pubdate/&gt;</span><br><span class="line"></span><br><span class="line">irb(main):020:0&gt; game.elements["pubdate"].text = "2011"</span><br><span class="line">=&gt; "2011"</span><br><span class="line"></span><br><span class="line">irb(main):021:0&gt; game.add_attribute("title", "League of Legends")</span><br><span class="line">=&gt; "League of Legends"</span><br><span class="line"></span><br><span class="line">irb(main):022:0&gt; puts doc2</span><br><span class="line">&lt;collection id='test'&gt;&lt;game title='League of Legends'&gt;&lt;company&gt;&lt;name&gt;Riot Games&lt;/name&gt;&lt;location&gt;America&lt;/location&gt;&lt;/company&gt;&lt;platform&gt;Microsoft Windows&lt;/platform&gt;&lt;/&gt;&lt;pubdate&gt;2011&lt;/pubdate&gt;&lt;/game&gt;&lt;/collection&gt;</span><br><span class="line">=&gt; nil</span><br><span class="line"></span><br><span class="line">irb(main):030:0&gt; doc2.write(:indent =&gt; 2)</span><br><span class="line">&lt;collection id='test'&gt;</span><br><span class="line">  &lt;game title='League of Legends'&gt;</span><br><span class="line">    &lt;company&gt;</span><br><span class="line">      &lt;name&gt;</span><br><span class="line">        Riot Games</span><br><span class="line">      &lt;/name&gt;</span><br><span class="line">      &lt;location&gt;</span><br><span class="line">        America</span><br><span class="line">      &lt;/location&gt;</span><br><span class="line">    &lt;/company&gt;</span><br><span class="line">    &lt;platform&gt;</span><br><span class="line">      Microsoft Windows</span><br><span class="line">    &lt;/platform&gt;</span><br><span class="line">    &lt;pubdate&gt;</span><br><span class="line">      2011</span><br><span class="line">    &lt;/pubdate&gt;</span><br><span class="line">  &lt;/game&gt;</span><br><span class="line">&lt;/collection&gt;</span><br><span class="line">=&gt; [&lt;?xml ... ?&gt;, &lt;collection id='test'&gt; ... &lt;/&gt;]</span><br></pre></td></tr></table></figure><p>通过<code>Element.add_attribution</code>可以添加元素属性，第一个参数时key，第二个参数是值；通过<code>Element.new</code>和<code>Element.add_element</code>都可以添加新的元素，但前者需要使用<code>&lt;&lt;</code>方法添加到其父元素下，<code>&lt;&lt;</code>方法是 <code>Elements.add</code>的别名；可以通过<code>Element.text</code>添加或修改元素的文本值； 最后可以通过<code>Document.write</code>输出document</p><p>如果想在指定位置插入元素，可以使用<code>Element.insert_before</code> 和<code>Element.insert_after</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">irb(main):031:0&gt; platform2 = Element.new("platform")</span><br><span class="line">=&gt; &lt;platform/&gt;</span><br><span class="line"></span><br><span class="line">irb(main):032:0&gt; platform2.add_text("MacOS X")</span><br><span class="line">=&gt; &lt;platform&gt; ... &lt;/&gt;</span><br><span class="line"></span><br><span class="line">irb(main):034:0&gt; doc2.root.insert_before("//pubdate", platform2)</span><br><span class="line">=&gt; &lt;collection id='test'&gt; ... &lt;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;collection id='test'&gt;</span><br><span class="line">  &lt;game title='League of Legends'&gt;</span><br><span class="line">    &lt;company&gt;</span><br><span class="line">      &lt;name&gt;</span><br><span class="line">        Riot Games</span><br><span class="line">      &lt;/name&gt;</span><br><span class="line">      &lt;location&gt;</span><br><span class="line">        America</span><br><span class="line">      &lt;/location&gt;</span><br><span class="line">    &lt;/company&gt;</span><br><span class="line">    &lt;platform&gt;</span><br><span class="line">      Microsoft Windows</span><br><span class="line">    &lt;/platform&gt;</span><br><span class="line">    &lt;platform&gt;</span><br><span class="line">      MacOS X</span><br><span class="line">    &lt;/platform&gt;</span><br><span class="line">    &lt;pubdate&gt;</span><br><span class="line">      2011</span><br><span class="line">    &lt;/pubdate&gt;</span><br><span class="line">  &lt;/game&gt;</span><br><span class="line">&lt;/collection&gt;</span><br><span class="line">=&gt; [&lt;?xml ... ?&gt;, &lt;collection id='test'&gt; ... &lt;/&gt;]</span><br></pre></td></tr></table></figure><h5 id="删除元素和属性"><a href="#删除元素和属性" class="headerlink" title="删除元素和属性"></a>删除元素和属性</h5><p>删除元素和属性的方法分别是<code>Element.delete_attribute</code>和<code>Element.delete_element</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">irb(main):040:0&gt; doc2.root.delete_attribute("id")</span><br><span class="line">=&gt; &lt;collection&gt; ... &lt;/&gt;</span><br><span class="line"></span><br><span class="line">irb(main):042:0&gt; doc2.write(:indent =&gt; 2)</span><br><span class="line">&lt;collection&gt;</span><br><span class="line">  &lt;game title='League of Legends'&gt;</span><br><span class="line">    &lt;company&gt;</span><br><span class="line">      &lt;name&gt;</span><br><span class="line">        Riot Games</span><br><span class="line">      &lt;/name&gt;</span><br><span class="line">      &lt;location&gt;</span><br><span class="line">        America</span><br><span class="line">      &lt;/location&gt;</span><br><span class="line">    &lt;/company&gt;</span><br><span class="line">    &lt;platform&gt;</span><br><span class="line">      Microsoft Windows</span><br><span class="line">    &lt;/platform&gt;</span><br><span class="line">    &lt;platform&gt;</span><br><span class="line">      MacOS X</span><br><span class="line">    &lt;/platform&gt;</span><br><span class="line">    &lt;pubdate&gt;</span><br><span class="line">      2011</span><br><span class="line">    &lt;/pubdate&gt;</span><br><span class="line">  &lt;/game&gt;</span><br><span class="line">&lt;/collection&gt;</span><br><span class="line">=&gt; [&lt;?xml ... ?&gt;, &lt;collection&gt; ... &lt;/&gt;]</span><br><span class="line"></span><br><span class="line">irb(main):044:0&gt; doc2.delete_element("//pubdate")</span><br><span class="line">=&gt; &lt;pubdate&gt; ... &lt;/&gt;</span><br><span class="line"></span><br><span class="line">irb(main):045:0&gt; doc2.write(:indent =&gt; 2)</span><br><span class="line">&lt;collection&gt;</span><br><span class="line">  &lt;game title='League of Legends'&gt;</span><br><span class="line">    &lt;company&gt;</span><br><span class="line">      &lt;name&gt;</span><br><span class="line">        Riot Games</span><br><span class="line">      &lt;/name&gt;</span><br><span class="line">      &lt;location&gt;</span><br><span class="line">        America</span><br><span class="line">      &lt;/location&gt;</span><br><span class="line">    &lt;/company&gt;</span><br><span class="line">    &lt;platform&gt;</span><br><span class="line">      Microsoft Windows</span><br><span class="line">    &lt;/platform&gt;</span><br><span class="line">    &lt;platform&gt;</span><br><span class="line">      MacOS X</span><br><span class="line">    &lt;/platform&gt;</span><br><span class="line">  &lt;/game&gt;</span><br><span class="line">&lt;/collection&gt;</span><br><span class="line">=&gt; [&lt;?xml ... ?&gt;, &lt;collection&gt; ... &lt;/&gt;]</span><br><span class="line"></span><br><span class="line">irb(main):046:0&gt; doc2.root.delete_element(1)</span><br><span class="line">=&gt; &lt;game title='League of Legends'&gt; ... &lt;/&gt;</span><br><span class="line"></span><br><span class="line">irb(main):047:0&gt; doc2.write(:indent =&gt; 2)</span><br><span class="line">&lt;collection/&gt;</span><br><span class="line">=&gt; [&lt;?xml ... ?&gt;, &lt;collection/&gt;]</span><br><span class="line"></span><br><span class="line">irb(main):048:0&gt; puts doc2</span><br><span class="line">&lt;collection/&gt;</span><br><span class="line">=&gt; nil</span><br></pre></td></tr></table></figure><p>通过<code>delete_attribuite</code>来删除属性，参数为属性的<code>key</code>，通过<code>delete_element</code>来删除元素，参数和<code>Elements</code>的<code>[]</code>方法一样，可以是子元素的索引(从1开始)和XPath定位。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Ruby处理Xml主要使用内置的库&lt;a href=&quot;https://ruby-doc.org/stdlib-2.1.2/libdoc/rexml/rdoc/REXML/Document.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;R
      
    
    </summary>
    
    
      <category term="Ruby" scheme="https://blog.ache.fun/tags/Ruby/"/>
    
  </entry>
  
  <entry>
    <title>golang 中的Plugin</title>
    <link href="https://blog.ache.fun/2018/09/16/golang%E4%B8%AD%E7%9A%84Plugin/"/>
    <id>https://blog.ache.fun/2018/09/16/golang中的Plugin/</id>
    <published>2018-09-16T13:48:38.000Z</published>
    <updated>2018-09-16T15:41:33.918Z</updated>
    
    <content type="html"><![CDATA[<p>前段时间在使用超级账本的时候，发现其中的系统链码(chaincode)链接到节点(peer)可以通过golang的plugin的方式，记录下其用法</p><p>plugin是golang1.8之后加入的，目前只能在Linux和macOS上使用。一个插件是一个Go的main包，其中有导出的函数和变量，这些函数和变量是用以下方法构建的:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> go build -buildmode=plugin</span><br></pre></td></tr></table></figure><h5 id="定义插件"><a href="#定义插件" class="headerlink" title="定义插件"></a>定义插件</h5><p>我们使用cat.go和dog.go分别定义两个插件</p><p>cat.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> animalia <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a animalia)</span> <span class="title">Greet</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"Meow~"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出变量Animal</span></span><br><span class="line"><span class="keyword">var</span> Animal animalia</span><br></pre></td></tr></table></figure><p>dog.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> animalia <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a animalia)</span> <span class="title">Greet</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"Bowwow~"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出变量Animal</span></span><br><span class="line"><span class="keyword">var</span> Animal animalia</span><br></pre></td></tr></table></figure><h5 id="编译插件"><a href="#编译插件" class="headerlink" title="编译插件"></a>编译插件</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> go build -buildmode=plugin -o cat.so cat.go</span><br><span class="line"><span class="meta">$</span> go build -buildmode=plugin -o dog.so dog.go</span><br></pre></td></tr></table></figure><h5 id="使用插件"><a href="#使用插件" class="headerlink" title="使用插件"></a>使用插件</h5><p>greeter.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"plugin"</span>; ...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Animalia <span class="keyword">interface</span> &#123;</span><br><span class="line">Greet()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">animal := <span class="string">"cat"</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(os.Args) == <span class="number">2</span> &#123;</span><br><span class="line">lang = os.Args[<span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> mod <span class="keyword">string</span></span><br><span class="line"><span class="keyword">switch</span> lang &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"cat"</span>:</span><br><span class="line">mod = <span class="string">"./cat/cat.so"</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">"dog"</span>:</span><br><span class="line">mod = <span class="string">"./dog/dog.so"</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Println(<span class="string">"don't find animal"</span>)</span><br><span class="line">os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载模块</span></span><br><span class="line"><span class="comment">// 打开so文件，加载其中的符号</span></span><br><span class="line">plug, err := plugin.Open(mod)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line">os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 查找符号，导出的变量或函数</span></span><br><span class="line"><span class="comment">// 此例中为Animal</span></span><br><span class="line">symGreeter, err := plug.Lookup(<span class="string">"Animal"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line">os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 断言加载的符号</span></span><br><span class="line">    <span class="comment">// 此例中是上文定义的Greeter</span></span><br><span class="line"><span class="keyword">var</span> greeter Greeter</span><br><span class="line">greeter, ok := symGreeter.(Greeter)</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line">fmt.Println(<span class="string">"unexpected type from module symbol"</span>)</span><br><span class="line">os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 使用导入的符号</span></span><br><span class="line">greeter.Greet()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="运行程序"><a href="#运行程序" class="headerlink" title="运行程序"></a>运行程序</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">go</span> run greeter.<span class="keyword">go</span> cat</span><br><span class="line">Meow~</span><br><span class="line"></span><br><span class="line">$ <span class="keyword">go</span> run greeter.<span class="keyword">go</span> dog</span><br><span class="line">Bowwow~</span><br></pre></td></tr></table></figure><h5 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h5><ul><li><a href="https://medium.com/learning-the-go-programming-language/writing-modular-go-programs-with-plugins-ec46381ee1a9" target="_blank" rel="noopener">Writing Modular Go Programs with Plugins</a></li><li><a href="https://golang.org/pkg/plugin/" target="_blank" rel="noopener">golang packege plugin</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前段时间在使用超级账本的时候，发现其中的系统链码(chaincode)链接到节点(peer)可以通过golang的plugin的方式，记录下其用法&lt;/p&gt;
&lt;p&gt;plugin是golang1.8之后加入的，目前只能在Linux和macOS上使用。一个插件是一个Go的main
      
    
    </summary>
    
    
      <category term="Go" scheme="https://blog.ache.fun/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>traefik使用docker配置后端</title>
    <link href="https://blog.ache.fun/2018/09/08/traefik%E4%BD%BF%E7%94%A8docker%E9%85%8D%E7%BD%AE%E5%90%8E%E7%AB%AF/"/>
    <id>https://blog.ache.fun/2018/09/08/traefik使用docker配置后端/</id>
    <published>2018-09-08T03:18:59.000Z</published>
    <updated>2018-09-16T14:57:54.749Z</updated>
    
    <content type="html"><![CDATA[<p>Traefik 是一款开源的反向代理与负载均衡工具。它最大的优点是能够与常见的微服务系统直接整合，可以实现自动化动态配置。目前支持 Docker、Swarm、Mesos/Marathon、 Mesos、Kubernetes、Consul、Etcd、Zookeeper、BoltDB、Rest API 等等后端模型。 支持简单的统计，限流等，本文只介绍最简单的docker作为后端。</p><h3 id="准备配置"><a href="#准备配置" class="headerlink" title="准备配置"></a>准备配置</h3><h5 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h5><p><strong>Entrypoints</strong></p><p>入口点是进入treafik的网络入口点。可以使用以下方法定义它们:</p><ul><li>一个端口(80,443…)</li><li>SSL(证书、密钥、使用受信任CA签名的客户端证书的身份验证…)</li><li>重定向到另一个入口点(将HTTP重定向到HTTPS )</li></ul><p><strong>Frontends</strong></p><p>前端由一组规则组成，这些规则决定如何将传入请求从入口点转发到后端。</p><p>规则可以分为两类:修饰词和匹配词。</p><p><em>修饰词</em></p><p>修饰词规则仅仅修改请求，它们对正在做出的路由决策没有任何影响。</p><p>以下是现有修饰词规则的列表:</p><ul><li><code>AddPrefix: /products</code>在将请求转发到后端之前，向现有请求路径添加路径前缀。</li><li><code>ReplacePath: /serverless-path</code>替换路径并将旧路径添加到X替换路径标题中。适用于映射到AWS Lambda或谷歌云功能。</li><li><code>ReplacePathRegex: ^/api/v2/(.*) /api/$1</code>用正则表达式替换路径，并将旧路径添加到X替换路径标题中。用空格分隔正则表达式和替换。</li></ul><p><strong>匹配词</strong></p><p>匹配器规则确定是否应将特定请求转发到后端。</p><p><strong>Backends</strong></p><p>后端负责负载平衡来自一个或多个前端到一组http服务器的流量。</p><h5 id="traefik-toml"><a href="#traefik-toml" class="headerlink" title="traefik.toml"></a>traefik.toml</h5><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># debug = true</span></span><br><span class="line"><span class="attr">logLevel</span> = <span class="string">"DEBUG"</span></span><br><span class="line"><span class="comment">################################################################</span></span><br><span class="line"><span class="comment"># API and dashboard configuration</span></span><br><span class="line"><span class="comment">################################################################</span></span><br><span class="line"><span class="section">[api]</span></span><br><span class="line"><span class="attr">entryPoint</span> = <span class="string">"traefik"</span></span><br><span class="line"><span class="comment">################################################################</span></span><br><span class="line"><span class="comment"># Docker configuration backend</span></span><br><span class="line"><span class="comment">################################################################</span></span><br><span class="line"><span class="section">[docker]</span></span><br><span class="line"><span class="attr">domain</span> = <span class="string">"localhost"</span></span><br><span class="line"><span class="attr">watch</span> = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="attr">defaultEntryPoints</span> = [<span class="string">"http"</span>, <span class="string">"https"</span>]</span><br><span class="line"></span><br><span class="line"><span class="section">[entryPoints]</span></span><br><span class="line"><span class="section">  [entryPoints.http]</span></span><br><span class="line">  address = ":80"</span><br><span class="line"><span class="section">  [entryPoints.traefik]</span></span><br><span class="line">  address = ":8080"</span><br><span class="line">    <span class="comment"># [entryPoints.traefik.auth.basic]</span></span><br><span class="line">    <span class="comment"># users = ["liank:$apr1$fhBEU6Vy$g5mO1OFoecu68jh7vriVh0"]</span></span><br><span class="line"><span class="section">    [entryPoints.traefik.auth.digest]</span></span><br><span class="line">    usersFile = "/.htdigest"</span><br><span class="line">    <span class="comment"># [entryPoints.traefik.auth.forward]</span></span><br><span class="line">    <span class="comment"># address = "http://10.0.1.8:8888/auth"</span></span><br><span class="line">    <span class="comment"># trustForwardHeader = true</span></span><br></pre></td></tr></table></figure><p>其中<code>entryPoints.traefik.auth.digest</code>是仪表盘的认证，使用digest 认证。使用<code>htdigest</code>工具生成账号和密码，使用方法如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> htdigest -h</span><br><span class="line">Usage: htdigest [-c] passwordfile realm username</span><br><span class="line">The -c flag creates a new file.</span><br></pre></td></tr></table></figure><h5 id="docker-compose"><a href="#docker-compose" class="headerlink" title="docker compose"></a>docker compose</h5><p>traefik单独使用一个docker-compose.yml，配置如下</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3'</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="attr">  traefik:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">traefik</span></span><br><span class="line"><span class="attr">    restart:</span> <span class="string">always</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="number">80</span><span class="string">:80</span></span><br><span class="line"><span class="bullet">      -</span> <span class="number">443</span><span class="string">:443</span></span><br><span class="line">      <span class="comment"># - 8080:8080</span></span><br><span class="line"><span class="attr">    networks:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">web</span></span><br><span class="line"><span class="attr">    volumes:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">/var/run/docker.sock:/var/run/docker.sock</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">./traefik.toml:/traefik.toml</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">./acme.json:/acme.json</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">./.htdigest:/.htdigest</span></span><br><span class="line"><span class="attr">    container_name:</span> <span class="string">traefik</span></span><br><span class="line"><span class="attr">    labels:</span> </span><br><span class="line"><span class="bullet">      -</span> <span class="string">"traefik.frontend.rule=Host:monitor.$&#123;DOMAIN&#125;"</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"traefik.port=8080"</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"traefik.protocol=http"</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"traefik.docker.network=web"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line"><span class="attr">  web:</span></span><br><span class="line"><span class="attr">    external:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>在这之前需要使用<code>docker network create</code> 创建一个网络</p><h3 id="配置后端"><a href="#配置后端" class="headerlink" title="配置后端"></a>配置后端</h3><p>业务容器配置到另一个docker-compse中</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">"3"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="attr">  app:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">my-docker-registry.com/my-awesome-app/app:latest</span></span><br><span class="line"><span class="attr">    depends_on:</span></span><br><span class="line"><span class="attr">      db:</span></span><br><span class="line"><span class="attr">        condition:</span> <span class="string">service_healthy</span></span><br><span class="line"><span class="attr">      redis:</span></span><br><span class="line"><span class="attr">        condition:</span> <span class="string">service_healthy</span></span><br><span class="line"><span class="attr">    restart:</span> <span class="string">always</span></span><br><span class="line"><span class="attr">    networks:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">web</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">default</span></span><br><span class="line"><span class="attr">    expose:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"9000"</span></span><br><span class="line"><span class="attr">    labels:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"traefik.docker.network=web"</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"traefik.enable=true"</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"traefik.basic.frontend.rule=Host:app.my-awesome-app.org"</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"traefik.basic.port=9000"</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"traefik.basic.protocol=http"</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"traefik.admin.frontend.rule=Host:admin-app.my-awesome-app.org"</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"traefik.admin.protocol=https"</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"traefik.admin.port=9443"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  db:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">my-docker-registry.com/back-end/5.7</span></span><br><span class="line"><span class="attr">    restart:</span> <span class="string">always</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  redis:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">my-docker-registry.com/back-end/redis:4-alpine</span></span><br><span class="line"><span class="attr">    restart:</span> <span class="string">always</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  events:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">my-docker-registry.com/my-awesome-app/events:latest</span></span><br><span class="line"><span class="attr">    depends_on:</span></span><br><span class="line"><span class="attr">      db:</span></span><br><span class="line"><span class="attr">        condition:</span> <span class="string">service_healthy</span></span><br><span class="line"><span class="attr">      redis:</span></span><br><span class="line"><span class="attr">        condition:</span> <span class="string">service_healthy</span></span><br><span class="line"><span class="attr">    restart:</span> <span class="string">always</span></span><br><span class="line"><span class="attr">    networks:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">web</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">default</span></span><br><span class="line"><span class="attr">    expose:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"3000"</span></span><br><span class="line"><span class="attr">    labels:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"traefik.backend=my-awesome-app-events"</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"traefik.docker.network=web"</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"traefik.frontend.rule=Host:events.my-awesome-app.org"</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"traefik.enable=true"</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"traefik.port=3000"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line"><span class="attr">  web:</span></span><br><span class="line"><span class="attr">    external:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p><strong>Labels</strong></p><p>Labels部分是指定Traefik配置的地方。docker labels本身没有任何作用，但是Traefik读取这些标签，因此它知道如何处理容器。完整的labels参见<a href="https://docs.traefik.io/configuration/backends/docker/#on-containers" target="_blank" rel="noopener">官方文档</a></p><p><code>traefik.enable=false</code>表示traefik应忽略该容器</p><p>当新添加容器时，不需要重启traefik就能检测到，因为traefik会通过它监听的docker套接字文件发现新的容器。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Traefik 是一款开源的反向代理与负载均衡工具。它最大的优点是能够与常见的微服务系统直接整合，可以实现自动化动态配置。目前支持 Docker、Swarm、Mesos/Marathon、 Mesos、Kubernetes、Consul、Etcd、Zookeeper、Bol
      
    
    </summary>
    
    
      <category term="docker" scheme="https://blog.ache.fun/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Postgres中的JSON操作</title>
    <link href="https://blog.ache.fun/2018/09/02/Postgres%E4%B8%AD%E7%9A%84JSON%E6%93%8D%E4%BD%9C/"/>
    <id>https://blog.ache.fun/2018/09/02/Postgres中的JSON操作/</id>
    <published>2018-09-02T09:06:32.000Z</published>
    <updated>2018-09-03T01:05:49.995Z</updated>
    
    <content type="html"><![CDATA[<p>记录下Postgres的JSON相关操作</p><h3 id="准备表结构和数据"><a href="#准备表结构和数据" class="headerlink" title="准备表结构和数据"></a>准备表结构和数据</h3><p>表结构</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> orders (</span><br><span class="line"> <span class="keyword">ID</span> <span class="built_in">serial</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> PRIMARY <span class="keyword">KEY</span>,</span><br><span class="line"> info <span class="keyword">json</span> <span class="keyword">NOT</span> <span class="literal">NULL</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> orders (info)</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line"> (</span><br><span class="line"> <span class="string">'&#123; "customer": "Lily Bush", "items": [&#123;"product": "Diaper","qty": 24&#125;, &#123;"product": "PC","qty": 300&#125;]&#125;'</span></span><br><span class="line"> ),</span><br><span class="line"> (</span><br><span class="line"> <span class="string">'&#123; "customer": "Josh William", "items": [&#123;"product": "Toy Car","qty": 1&#125;, &#123;"product": "NoteBook","qty": 2&#125;]&#125;'</span></span><br><span class="line"> ),</span><br><span class="line"> (</span><br><span class="line"> <span class="string">'&#123; "customer": "Mary Clark", "items": [&#123;"product": "Toy Train","qty": 2&#125;]&#125;'</span></span><br><span class="line"> );</span><br></pre></td></tr></table></figure><p><img src="/images/pg-json-query-response0.png" alt=""></p><h3 id="查询JSON数据"><a href="#查询JSON数据" class="headerlink" title="查询JSON数据"></a>查询JSON数据</h3><h5 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h5><table><thead><tr><th style="text-align:center">Operator</th><th>Right Operand Type</th><th>Description</th><th style="text-align:center">Example</th><th style="text-align:center">Example Result</th></tr></thead><tbody><tr><td style="text-align:center"><code>-&gt;</code></td><td><code>int</code></td><td>Get JSON array element (indexed from zero, negative integers count from the end)</td><td style="text-align:center"><code>&#39;[{&quot;a&quot;:&quot;foo&quot;},{&quot;b&quot;:&quot;bar&quot;},{&quot;c&quot;:&quot;baz&quot;}]&#39;::json-&gt;2</code></td><td style="text-align:center"><code>{&quot;c&quot;:&quot;baz&quot;}</code></td></tr><tr><td style="text-align:center"><code>-&gt;</code></td><td><code>text</code></td><td>Get JSON object field by key</td><td style="text-align:center"><code>&#39;{&quot;a&quot;: {&quot;b&quot;:&quot;foo&quot;}}&#39;::json-&gt;&#39;a&#39;</code></td><td style="text-align:center"><code>{&quot;b&quot;:&quot;foo&quot;}</code></td></tr><tr><td style="text-align:center"><code>-&gt;&gt;</code></td><td><code>int</code></td><td>Get JSON array element as <code>text</code></td><td style="text-align:center"><code>&#39;[1,2,3]&#39;::json-&gt;&gt;2</code></td><td style="text-align:center"><code>3</code></td></tr><tr><td style="text-align:center"><code>-&gt;&gt;</code></td><td><code>text</code></td><td>Get JSON object field as <code>text</code></td><td style="text-align:center"><code>&#39;{&quot;a&quot;:1,&quot;b&quot;:2}&#39;::json-&gt;&gt;&#39;b&#39;</code></td><td style="text-align:center"><code>2</code></td></tr><tr><td style="text-align:center"><code>#&gt;</code></td><td><code>text[]</code></td><td>Get JSON object at specified path</td><td style="text-align:center"><code>&#39;{&quot;a&quot;: {&quot;b&quot;:{&quot;c&quot;: &quot;foo&quot;}}}&#39;::json#&gt;&#39;{a,b}&#39;</code></td><td style="text-align:center"><code>{&quot;c&quot;: &quot;foo&quot;}</code></td></tr><tr><td style="text-align:center"><code>#&gt;&gt;</code></td><td><code>text[]</code></td><td>Get JSON object at specified path as <code>text</code></td><td style="text-align:center"><code>&#39;{&quot;a&quot;:[1,2,3],&quot;b&quot;:[4,5,6]}&#39;::json#&gt;&gt;&#39;{a,2}&#39;</code></td><td style="text-align:center"><code>3</code></td></tr></tbody></table><p>使用运算符<code>-&gt;</code>获取JSON对象的字段</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line"> info -&gt; <span class="string">'customer'</span> <span class="keyword">AS</span> customer</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line"> orders;</span><br></pre></td></tr></table></figure><p><img src="/images/pg-json-query-response1.png" alt=""></p><p>使用<code>-&gt;&gt;</code>获取JSON对象的<strong>文本</strong>字段</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line"> info -&gt;&gt; <span class="string">'customer'</span> <span class="keyword">AS</span> customer</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line"> orders;</span><br></pre></td></tr></table></figure><p><img src="/images/pg-json-query-response2.png" alt=""></p><p>因为<code>-&gt;</code> operator返回一个JSON对象，可以链式操作检索特定的节点。例如，以下语句返回所有售出的产品:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line"> info -&gt; <span class="string">'items'</span> -&gt; <span class="number">0</span> -&gt;&gt; <span class="string">'product'</span> <span class="keyword">as</span> product</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line"> orders</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span></span><br><span class="line"> product;</span><br></pre></td></tr></table></figure><p><img src="/images/pg-json-query-response3.png" alt=""></p><p>第一个<code>info -&gt; &#39;item&#39;</code> 返回一个JSON对象，<code>info -&gt; &#39;items&#39; -&gt; 0</code>返回<code>items</code>数组中第一个元素的JSON对象，最后<code>info -&gt; &#39;items&#39; -&gt; 0 -&gt;&gt; &#39;product&#39;</code>以文本的形式返回所有的<code>product</code></p><h5 id="在WHERE语句中使用操作符"><a href="#在WHERE语句中使用操作符" class="headerlink" title="在WHERE语句中使用操作符"></a>在<code>WHERE</code>语句中使用操作符</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line"> info -&gt;&gt; <span class="string">'customer'</span> <span class="keyword">AS</span> customer</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line"> orders</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line"> info -&gt; <span class="string">'items'</span> -&gt; <span class="number">0</span> -&gt;&gt; <span class="string">'product'</span> = <span class="string">'Diaper'</span></span><br></pre></td></tr></table></figure><h3 id="聚合函数在JSON中的应用"><a href="#聚合函数在JSON中的应用" class="headerlink" title="聚合函数在JSON中的应用"></a>聚合函数在JSON中的应用</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line"> <span class="keyword">MIN</span> (</span><br><span class="line"> <span class="keyword">CAST</span> (</span><br><span class="line"> info -&gt; <span class="string">'items'</span> -&gt;<span class="number">0</span> -&gt;&gt; <span class="string">'qty'</span> <span class="keyword">AS</span> <span class="built_in">INTEGER</span></span><br><span class="line"> )</span><br><span class="line"> ),</span><br><span class="line"> <span class="keyword">MAX</span> (</span><br><span class="line"> <span class="keyword">CAST</span> (</span><br><span class="line"> info -&gt; <span class="string">'items'</span> -&gt;<span class="number">0</span> -&gt;&gt; <span class="string">'qty'</span> <span class="keyword">AS</span> <span class="built_in">INTEGER</span></span><br><span class="line"> )</span><br><span class="line"> ),</span><br><span class="line"> <span class="keyword">SUM</span> (</span><br><span class="line"> <span class="keyword">CAST</span> (</span><br><span class="line"> info -&gt; <span class="string">'items'</span> -&gt;<span class="number">0</span> -&gt;&gt; <span class="string">'qty'</span> <span class="keyword">AS</span> <span class="built_in">INTEGER</span></span><br><span class="line"> )</span><br><span class="line"> ),</span><br><span class="line"> <span class="keyword">AVG</span> (</span><br><span class="line"> <span class="keyword">CAST</span> (</span><br><span class="line"> info -&gt; <span class="string">'items'</span> -&gt;<span class="number">0</span> -&gt;&gt; <span class="string">'qty'</span> <span class="keyword">AS</span> <span class="built_in">INTEGER</span></span><br><span class="line"> )</span><br><span class="line"> )</span><br><span class="line"> </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line"> orders</span><br></pre></td></tr></table></figure><p><img src="/images/pg-json-query-response4.png" alt=""></p><h3 id="JSON处理函数"><a href="#JSON处理函数" class="headerlink" title="JSON处理函数"></a>JSON处理函数</h3><h5 id="json-each函数"><a href="#json-each函数" class="headerlink" title="json_each函数"></a><code>json_each</code>函数</h5><p>json_each()将最外面的JSON对象扩展成一组键/值对。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line"> json_each (info)</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line"> orders;</span><br></pre></td></tr></table></figure><p><img src="/images/pg-json-query-response5.png" alt=""></p><p>或者对于单条记录</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line"> * </span><br><span class="line"><span class="keyword">FROM</span> </span><br><span class="line"> json_each((<span class="keyword">select</span> info <span class="keyword">from</span> orders <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span>));</span><br></pre></td></tr></table></figure><p><img src="/images/pg-json-query-response6.png" alt=""></p><p><code>json_each_text</code>和<code>json_each</code>效果相同，返回的是文本类型</p><h5 id="json-object-key函数"><a href="#json-object-key函数" class="headerlink" title="json_object_key函数"></a><code>json_object_key</code>函数</h5><p><code>json_object_key()</code>返回最外面的JSON对象中的一组键。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line"> json_object_keys (info-&gt;<span class="string">'items'</span> -&gt;<span class="number">0</span>)</span><br><span class="line"> <span class="keyword">FROM</span></span><br><span class="line"> orders;</span><br></pre></td></tr></table></figure><p><img src="/images/pg-json-query-response7.png" alt=""></p><p>更多内容参照PostgreSQL<a href="https://www.postgresql.org/docs/10/static/functions-json.html" target="_blank" rel="noopener">官方文档</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;记录下Postgres的JSON相关操作&lt;/p&gt;
&lt;h3 id=&quot;准备表结构和数据&quot;&gt;&lt;a href=&quot;#准备表结构和数据&quot; class=&quot;headerlink&quot; title=&quot;准备表结构和数据&quot;&gt;&lt;/a&gt;准备表结构和数据&lt;/h3&gt;&lt;p&gt;表结构&lt;/p&gt;
&lt;figure cl
      
    
    </summary>
    
    
      <category term="数据库" scheme="https://blog.ache.fun/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="PostgreSQL" scheme="https://blog.ache.fun/tags/PostgreSQL/"/>
    
  </entry>
  
  <entry>
    <title>图灵机和图灵完备性</title>
    <link href="https://blog.ache.fun/2018/08/19/%E5%9B%BE%E7%81%B5%E6%9C%BA%E5%92%8C%E5%9B%BE%E7%81%B5%E5%AE%8C%E5%A4%87%E6%80%A7/"/>
    <id>https://blog.ache.fun/2018/08/19/图灵机和图灵完备性/</id>
    <published>2018-08-19T10:00:09.000Z</published>
    <updated>2018-08-19T15:40:53.059Z</updated>
    
    <content type="html"><![CDATA[<p>检索了很多资料之后，在coursera上发现了北京大学李戈老师的<a href="https://www.coursera.org/lecture/jisuanji-biancheng/cong-shu-xue-wei-ji-dao-tu-ling-ji-ieLnF" target="_blank" rel="noopener">计算导论与C语言基础</a>课程相当不错，这门课程很好的解释了图灵机的产生背景，构成，意义等。介于自己大学欠的太多基础理论，学习这门课程的同时在这里做下笔记。</p><h2 id="从数学危机到图灵机"><a href="#从数学危机到图灵机" class="headerlink" title="从数学危机到图灵机"></a>从数学危机到图灵机</h2><h5 id="第一次数学危机"><a href="#第一次数学危机" class="headerlink" title="第一次数学危机"></a>第一次数学危机</h5><p> 第一次数学危机是<strong>西帕索斯悖论</strong>，西帕索斯是公元前500年前著名的<strong>毕达哥拉斯学派</strong>代表人物毕达哥拉斯的学生。当时的毕达哥拉斯学派深信两点</p><ul><li>数是万物的本质，事物的性质是由某种数量关系决定的，万物按照一定的数量比例而构成和谐的秩序。</li><li>一切数均可表成整数或整数之比。</li></ul><p>但后来毕达哥拉斯自己又证明了<strong>勾股定理</strong>（西方叫做毕达哥拉斯定理），在这个定理的证明过程中，毕达哥拉斯发现某些直角三角形的三边之比是不能够用整数来表示的。这就很尴尬了，毕哥也慌了，这不是打我自己的脸嘛，他没有吭声，但他的学生西帕索斯也发现了这件事情，学生没有包袱啊，他就跟人们说，边长为1的正方形，它的对角线我们没法表示啊（根号2是无理数，无法用当时的整数之比来表示）。第一次数学危机由此产生，这个问题称之为<strong>西帕索斯悖论</strong>。</p><p>这次危机直到200年之后才得到缓解，当时有个人叫<strong>欧多克索斯</strong>，他建立起了一套完整的比例论，巧妙的避开了物无理数这一：“逻辑上的丑闻”，并保留住与之相关的一些结论，缓解了数学危机。但他的解决方式是借助<strong>几何方法</strong>，通过避免直接出现无理数实现的。他也推动了几何的发展。</p><p>这次危机真正的解决是在十九世纪下半叶，也就是实数确立之后，才得到真正的缓解。</p><h5 id="第二次数学危机"><a href="#第二次数学危机" class="headerlink" title="第二次数学危机"></a>第二次数学危机</h5><p>第二次数学危机是<strong>贝克莱</strong>悖论，与<strong>微积分</strong>有关，17世纪，<strong>牛顿</strong>和<strong>莱不尼兹</strong>在<strong>无穷小</strong>的分析之上各自建立了微积分理论。但当时很多人觉得这玩意儿有问题，最出名的就是<strong>贝克莱</strong>，他觉得无穷小量在牛顿的理论中“一会儿是零”，“一会儿又不是零”。贝克莱嘲笑无穷小量是“已死量的幽灵”<br><img src="/images/daoshu.jpeg" alt=""></p><p>主要体现在上图导数的推理过程中的dx作为分母是不应是零，但最后又当作零，这又是同一个推导过程。</p><ul><li>危机的缓解</li></ul><p>十九世纪七十年代，威尔斯、特斯拉、柯西、戴德金、康托尔等人建立了<strong>实数</strong>理论，在实数理论基础上，建立了极限论的基本定理，缓解了危机。但没有完美解决问题。</p><ul><li>新的问题</li></ul><p>魏尔斯特拉斯给出一个处处不可微的连续函数的例子，说明使用几何学的考虑重建的微积分基础是不可靠的，必须诉诸严格的概念和推理。于是推动了数学家们更深入的探讨数学分析的基础——实数论的问题，导致了<strong>集合论</strong>的诞生。</p><ul><li>集合论</li></ul><p>十九世纪下半叶，<strong>康托尔</strong>创立了著名的<strong>集合论</strong>，<strong>集合论对计算机理论而言是一个非常基础的理论</strong>，刚产生时，曾遭到许多人的猛烈攻击。后来人们发现，从自然数与康托尔集合论出发可建立起整个数学大厦。“一切数学成果可建立在集合论基础上”。庞加莱在1900年国际数学家大会上宣称，借助集合论概念，我们可以构建起整个数学大厦。今天我们可以说绝对的严格性已经达到了。</p><h5 id="第三次数学危机"><a href="#第三次数学危机" class="headerlink" title="第三次数学危机"></a>第三次数学危机</h5><p>就在庞加莱宣称集合论已经很严格的时候，<strong>罗素</strong>站出来提出了个通俗的问题</p><blockquote><p>塞尔维亚有一位理发师，他只给所有不给自己理发的人理发，不给那些给自己理发的人理发。问：理发师他要不要给自己理发呢？？？？</p></blockquote><p>这就是<strong>罗素悖论</strong>，即S由一切不是自身元素的集合所组成。罗素问：“S是否属于S呢？”，通过这个例子发现集合论也不是完美的。能不能找到一个更加完备的系统，从上面建立数学大厦呢？当然能！</p><p><strong>哥德尔</strong>1931年成功证明了</p><blockquote><p>任何一个数学系统，只要它是从有限的公理和基本概念中推导出来的，并且从中能推证出自然数系统，就可以在其中找到一个命题，对于它我们<strong>既没有办法证明</strong>，又没有办法推翻。</p></blockquote><p>后来人们把这个证明称为<strong>哥德尔不完备性定理</strong>，好好奇啊，这种证明是怎么证明出来的。</p><p>哥德尔不完全定理的证明结束了关于数学基础的争论，宣告了把数学彻底形式化的愿望是不可能实现的。不存在一个完美的系统。</p><h5 id="接下来的问题"><a href="#接下来的问题" class="headerlink" title="接下来的问题"></a>接下来的问题</h5><p>那么在一个系统中，有些问题是既不能被证真，也不能被证伪，有些问题则是可以被证真或被证伪，那么这两种问题的边界在哪里？又如何去判定到底一个问题是否真的有解？在计算机中，这个问题归结为<strong>可计算</strong>问题，也就是说假设有一个函数，它的定义域是D，值域是R，如果存在一个算法，对于D中任意给定的x，都能够计算出f(x)的值。存在一个算法，只要给出D中的一个x，我都能计算出f(x)的值，那么就称为这个函数f(x)是可以计算的，否则，它就是不可计算的。 </p><p>那如何判定一个问题是否可计算呢？</p><p>为这个<strong>计算</strong>建立一个数学模型。就是我们用一个数学模型来模拟这个计算，这个模型当然被称为计算模型，然后我们来证明凡是这个计算模型能够完成的任务，都是能够计算的任务，凡是这个计算模型不能够完成的任务，那么都是不可计算的任务。也就是说这个计算模型就像一个评价器一样，它能够评价出哪些问题是可计算的，哪些问题是不可计算的，我们现在需要寻找的就是这样一个模型。</p><p>然后重点来了，<strong>图灵</strong>就提出了这样一个模型，这个模型就是<strong>图灵机</strong></p><p>1936年，图灵在其著名的论文《论可计算数在判定问题中的应用》一文中提出了一种理想的计算机器的数学模型-图灵机（TuringMachine）</p><h2 id="图灵机的基本构成"><a href="#图灵机的基本构成" class="headerlink" title="图灵机的基本构成"></a>图灵机的基本构成</h2><h5 id="基本构成"><a href="#基本构成" class="headerlink" title="基本构成"></a>基本构成</h5><ul><li>一条存储带<ul><li>双向无限延长</li><li>上有一个个小方格</li><li>每个小方格可存储一个数字/字母</li></ul></li><li>一个控制器<ul><li>包含一个读写头，可以读、写、更改存储带上每一格的数字/字母</li><li>可以接受设定好的程序语句</li><li>可以存储当前自身的状态（有限个状态位）</li><li>可以变换自身的状态</li><li>可以沿着存储带一格一格地左移/右移</li></ul></li></ul><p>诺，就是这个样子<br><img src="/images/turing-machine.jpeg" alt=""></p><h5 id="图灵机的工作步骤"><a href="#图灵机的工作步骤" class="headerlink" title="图灵机的工作步骤"></a>图灵机的工作步骤</h5><ol><li>准备<ol><li>存储带上的符号初始化</li><li>控制器设置好自身当前状态</li><li>控制器置于起始位置</li><li>准备好工作程序</li></ol></li><li>反复执行以下工作直到停机<ol><li>读写头读出存储带上当前方格中的字母/数字</li><li>根据自身当前状态和所读到的字符，找到相应的程序语句</li><li>根据相应程序语句，做三个动作<ol><li>在当前存储带方格上写入一个相应的字母/数字</li><li>变更自身状态至新状态</li><li>读写头向左或向右移一步</li></ol></li></ol></li></ol><h2 id="图灵完备"><a href="#图灵完备" class="headerlink" title="图灵完备"></a>图灵完备</h2><p>在可计算性理论里，如果一系列<strong>操作数据的规则</strong>（如指令集、编程语言、细胞自动机）可以用来模拟以上的图灵机的全部功能时，那么它是图灵完备的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;检索了很多资料之后，在coursera上发现了北京大学李戈老师的&lt;a href=&quot;https://www.coursera.org/lecture/jisuanji-biancheng/cong-shu-xue-wei-ji-dao-tu-ling-ji-ieLnF&quot; ta
      
    
    </summary>
    
    
      <category term="计算机理论" scheme="https://blog.ache.fun/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>《万历十五年》读书笔记</title>
    <link href="https://blog.ache.fun/2018/08/16/%E3%80%8A%E4%B8%87%E5%8E%86%E5%8D%81%E4%BA%94%E5%B9%B4%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>https://blog.ache.fun/2018/08/16/《万历十五年》读书笔记/</id>
    <published>2018-08-16T03:25:19.000Z</published>
    <updated>2018-08-18T15:49:53.435Z</updated>
    
    <content type="html"><![CDATA[<p>不知何时开始，突然对历史感兴趣了，好像是因为实习时的一位上级，他在精通各种技术的同时，又能出口成章，引经据典，当时就被他的人格魅力所吸引。但又好像是因为上半年看的《人类简史》中的一段话：</p><blockquote><p>究竟为什么要学历史？历史不像是物理学或经济学，目的不在于做出准确预测。我们之所以研究历史，不是为了要知道未来，而是要拓展视野，要了解现在的种种绝非“自然”，也并非无可避免。</p></blockquote><p>喜欢历史的原因暂时无法考究，但历史本身却一直有料。</p><p>黄大师以明朝的几个人的生平来描述了万历皇帝时期社会的现状，把两千年来社会最大的症结归根于用道德代替法制。在这样的背景下，装腔作势的文官们统治着社会，压制着军事力量，不管是张居正、海瑞的极端进步，还是申时行、戚继光、万历的相对妥协，都解决不了根本的问题。这本书中不像历史电视剧那样的极端，其中没有绝对的善恶忠奸，也没有绝对的好坏，张居正、申时行、海瑞、戚继光、万历皇帝…他们也有自己的苦恼、野心、妥协和无可奈何。</p><p>用道德代替法制，对当时的朝廷来讲，最大的问题就是那些文官们不是真正的为民为社会，他们不去研究制度的改革，管理方法的演进，却整天忙于利用现存体制上的罅隙来满足自己的私欲，和制衡皇帝和文官，文官和文官这些关系。在这过程中却又以仁义道德相标榜。这也就让文官们的双重性格发展的越来越明显。面对这样的现状，张居正，海瑞的态度很激进，他们想要改变，但却无法撼动那些为了维护稳定关系的文官们，最后都没怎么好过。申时行，戚继光他们则看清了现实，在不影响各种关系平衡和利益的基础上小心谨慎的为这个朝代打着补丁，却依然徒劳无功。</p><p>以作者的收官一章来总结吧</p><blockquote><p>1587年，是为万历十五年，丁亥次岁，表面上似乎是四海升平，无事可记，实际上我们的大明帝国却已经走到了它发展的尽头。在这个时候，皇帝的励精图治或者宴安眈乐，首辅的独裁或者调和，高级将领的富于创造或者习于苟安，文官的廉洁奉公或者贪污舞弊，思想家的极端进步或者绝对保守，最后的结果，都是无分善恶，统统不能在事业上取得有意义的发展，有的身败，有的名裂，还有的人则身败而兼名裂。</p></blockquote><p>个人能力有限，少于写作，希望以后写起东西来能够越来越顺畅吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;不知何时开始，突然对历史感兴趣了，好像是因为实习时的一位上级，他在精通各种技术的同时，又能出口成章，引经据典，当时就被他的人格魅力所吸引。但又好像是因为上半年看的《人类简史》中的一段话：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;究竟为什么要学历史？历史不像是物理学或经济学，
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://blog.ache.fun/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>记PostgreSQL几种实用操作</title>
    <link href="https://blog.ache.fun/2018/08/11/%E8%AE%B0PostgreSQL%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%94%A8%E6%93%8D%E4%BD%9C/"/>
    <id>https://blog.ache.fun/2018/08/11/记PostgreSQL几种实用操作/</id>
    <published>2018-08-11T11:40:26.000Z</published>
    <updated>2018-08-18T15:08:18.468Z</updated>
    
    <content type="html"><![CDATA[<p>记录最近用到的几种实用的PostgreSQL技巧</p><h2 id="备份-恢复"><a href="#备份-恢复" class="headerlink" title="备份-恢复"></a>备份-恢复</h2><h5 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> pg_dump -U username -h hostname -p port databasename -t “table1,table2” -f filename</span><br></pre></td></tr></table></figure><p>简写</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> pg_dump -U postgres drupal7 &gt; drupal.bak</span><br></pre></td></tr></table></figure><p><a href="https://www.postgresql.org/docs/current/static/app-pgdump.html" target="_blank" rel="noopener">官网文档</a></p><h5 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a>恢复</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> psql -U username -h hostname -d desintationdb -p port -f dumpfilename.sql</span><br></pre></td></tr></table></figure><p>简写</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> psql -U postgres drupal7 &lt; drupal.bak</span><br></pre></td></tr></table></figure><p><a href="https://www.postgresql.org/docs/10/static/app-psql.html" target="_blank" rel="noopener">官方文档</a></p><h2 id="几个聚合函数"><a href="#几个聚合函数" class="headerlink" title="几个聚合函数"></a>几个聚合函数</h2><p>array_agg，官方有两种使用方法分别是</p><p><img src="/images/postgresql-array_agg.png" alt=""></p><p><code>string_agg(*expression*,*delimiter*)</code>,参数(<code>text</code>, <code>text</code>) or (<code>bytea</code>, <code>bytea</code>)，使用输入值串接成字符串，用分隔符分隔</p><p><code>json_agg</code>和arrat_agg功能类似，只不过聚合成了json数组</p><p><a href="https://www.postgresql.org/docs/10/static/functions-aggregate.html" target="_blank" rel="noopener">全部聚合函数文档</a></p><h2 id="去除重复的行"><a href="#去除重复的行" class="headerlink" title="去除重复的行"></a>去除重复的行</h2><p>比如这样的一张表</p><table><thead><tr><th style="text-align:center">id</th><th style="text-align:center">fruit</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">apple</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">apple</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">orange</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">orange</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">orange</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">Banana</td></tr></tbody></table><p>删除重复的记录使用<code>DELETE USING</code>表达式</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    basket a</span><br><span class="line">        <span class="keyword">USING</span> basket b</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    a.id &lt; b.id</span><br><span class="line">    <span class="keyword">AND</span> a.fruit = b.fruit;</span><br></pre></td></tr></table></figure><p><a href="https://www.postgresql.org/docs/10/static/sql-delete.html" target="_blank" rel="noopener">官方文档</a>中是这样描述的</p><blockquote><p>PostgreSQL lets you reference columns of other tables in the <code>WHERE</code> condition by specifying the other tables in the <code>USING</code> clause. For example, to delete all films produced by a given producer, one can do:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; DELETE FROM films USING producers</span><br><span class="line">&gt;   WHERE producer_id = producers.id AND producers.name = 'foo';</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>其中的原理应该是把filems join到producers中，然后在根据producers的条件删除。上面的例子把basket表join到自身，然后只保留id最大的那条记录，就达到了去重的目的。</p><h2 id="在golang中使用postgresql的array类型"><a href="#在golang中使用postgresql的array类型" class="headerlink" title="在golang中使用postgresql的array类型"></a>在golang中使用postgresql的array类型</h2><p>使用<code>github.com/lib/pq</code>库其中有多种array类型，几种常见的如下</p><ul><li><p>Float64Array </p></li><li><p>StringArray</p></li><li><p>Int64Array</p><p>……</p></li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  ...</span><br><span class="line">  <span class="string">"github.com/lib/pq"</span></span><br><span class="line">  ...</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="keyword">type</span> Block <span class="keyword">struct</span> &#123;</span><br><span class="line">gorm.Model</span><br><span class="line">        .....</span><br><span class="line">Tx                pq.StringArray <span class="string">`gorm:"type:varchar(100)[]"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更多类型参见<a href="https://godoc.org/github.com/lib/pq#pkg-index" target="_blank" rel="noopener">官方文档</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;记录最近用到的几种实用的PostgreSQL技巧&lt;/p&gt;
&lt;h2 id=&quot;备份-恢复&quot;&gt;&lt;a href=&quot;#备份-恢复&quot; class=&quot;headerlink&quot; title=&quot;备份-恢复&quot;&gt;&lt;/a&gt;备份-恢复&lt;/h2&gt;&lt;h5 id=&quot;备份&quot;&gt;&lt;a href=&quot;#备份&quot; cla
      
    
    </summary>
    
    
      <category term="数据库" scheme="https://blog.ache.fun/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="PostgreSQL" scheme="https://blog.ache.fun/tags/PostgreSQL/"/>
    
  </entry>
  
  <entry>
    <title>几种语言中的装饰器</title>
    <link href="https://blog.ache.fun/2018/08/04/%E5%87%A0%E7%A7%8D%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E8%A3%85%E9%A5%B0%E5%99%A8/"/>
    <id>https://blog.ache.fun/2018/08/04/几种语言中的装饰器/</id>
    <published>2018-08-04T07:23:48.000Z</published>
    <updated>2018-08-18T15:08:30.779Z</updated>
    
    <content type="html"><![CDATA[<p>上个月使用Ts写Vue的项目时，分别尝试了基础构造器和类风格的写法，发现在类风格的写法中发现<code>vue-class-component</code>通常与<code>vue-property-decorator</code>一起使用，后者提供了很多vue的属性的修饰器。之后使用python的<code>scrapy</code>写项目时，又发现了<code>Scrapy</code>中也使用了修饰器，你说巧不巧，在上周写的一个node后端项目中又发现了修饰器的存在，这东西在短短一个月内，在我的眼前不断的刷新着存在感，看来确实需要和它确认下眼神。这里分别把Python，JS，TS，几种语言的修饰器使用简单的对比下</p><h2 id="从python说起"><a href="#从python说起" class="headerlink" title="从python说起"></a>从python说起</h2><blockquote><p>A Python decorator is a function that takes another function, extending the behavior of the latter function without explicitly modifying it.</p></blockquote><p>一个简单的装饰器</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'i am bar'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">use_logging_with_decorator</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        logging.warn(<span class="string">'%s is running'</span>, func.__name__)</span><br><span class="line">        <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line">bar = use_logging_with_decorator(bar)</span><br></pre></td></tr></table></figure><p>原理无非是把真正的业务函数包裹到一个装饰函数中，然后结合语法糖食用就变成了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@use_logging_with_decorator</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"i am bar"</span>)</span><br></pre></td></tr></table></figure><p>装饰器 decorator 接收一个参数，也就是我们被装饰的目标方法，处理完扩展的内容以后再返回一个方法，供以后调用，同时也失去了对原方法对象的访问。当我们对某个应用了装饰以后，其实就改变了被装饰方法的入口引用，使其重新指向了装饰器返回的方法的入口点，从而来实现我们对原函数的扩展、修改等操作。</p><p>使用装饰器后，原函数的元信息变成了装饰器的，把装饰器的元信息修改成原函数的，使用<code>functools</code>中的wraps</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">logged</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="meta">    @wraps(func)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">with_logging</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> func.__name__ + <span class="string">" was called"</span></span><br><span class="line">        <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> with_logging</span><br><span class="line"></span><br><span class="line"><span class="meta">@logged</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="string">"""does some math"""</span></span><br><span class="line">    <span class="keyword">return</span> x + x * x</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> f.__name__  <span class="comment"># prints 'f'</span></span><br><span class="line"><span class="keyword">print</span> f.__doc__   <span class="comment"># prints 'does some math'</span></span><br></pre></td></tr></table></figure><h4 id="python内置的装饰器"><a href="#python内置的装饰器" class="headerlink" title="python内置的装饰器"></a>python内置的装饰器</h4><p>@classmethod</p><p>classmethod 修饰符对应的函数不需要实例化，不需要 self 参数，但第一个参数需要是表示自身类的 cls 参数，可以来调用类的属性，类的方法，实例化对象等。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line">    bar = <span class="number">1</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func1</span><span class="params">(self)</span>:</span>  </span><br><span class="line">        <span class="keyword">print</span> (<span class="string">'foo'</span>) </span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func2</span><span class="params">(cls)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> (<span class="string">'func2'</span>)</span><br><span class="line">        <span class="keyword">print</span> (cls.bar)</span><br><span class="line">        cls().func1()   <span class="comment"># 调用 foo 方法</span></span><br><span class="line"> </span><br><span class="line">A.func2()               <span class="comment"># 不需要实例化</span></span><br></pre></td></tr></table></figure><p>@ staticmethod</p><p>python staticmethod 返回函数的静态方法。</p><p>该方法不强制要求传递参数，如下声明一个静态方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">'runoob'</span>);</span><br><span class="line"> </span><br><span class="line">C.f();          <span class="comment"># 静态方法无需实例化</span></span><br><span class="line">cobj = C()</span><br><span class="line">cobj.f()        <span class="comment"># 也可以实例化后调用</span></span><br></pre></td></tr></table></figure><p>@property</p><p><code>@property</code>装饰器就是负责把一个方法变成属性调用的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">score</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._score</span><br><span class="line"></span><br><span class="line"><span class="meta">    @score.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">score</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> isinstance(value, int):</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'score must be an integer!'</span>)</span><br><span class="line">        <span class="keyword">if</span> value &lt; <span class="number">0</span> <span class="keyword">or</span> value &gt; <span class="number">100</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'score must between 0 ~ 100!'</span>)</span><br><span class="line">        self._score = value</span><br></pre></td></tr></table></figure><p>把一个getter方法变成属性，只需要加上<code>@property</code>就可以了，此时，<code>@property</code>本身又创建了另一个装饰器<a href="mailto:`@score.setter" target="_blank" rel="noopener">`@score.setter</a>`，负责把一个setter方法变成属性赋值，于是，我们就拥有一个可控的属性操作：</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = Student()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.score = <span class="number">60</span> <span class="comment"># OK，实际转化为s.set_score(60)</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.score <span class="comment"># OK，实际转化为s.get_score()</span></span><br><span class="line"><span class="number">60</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.score = <span class="number">9999</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  ...</span><br><span class="line">ValueError: score must between <span class="number">0</span> ~ <span class="number">100</span>!</span><br></pre></td></tr></table></figure><p>当某个属性不是直接暴露，而是通过getter和setter方法来实现的时候，就可以使用@property</p><p>还可以定义只读属性，只定义getter方法，不定义setter方法就是一个只读属性：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">birth</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._birth</span><br><span class="line"></span><br><span class="line"><span class="meta">    @birth.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">birth</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        self._birth = value</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">age</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">2018</span> - self._birth</span><br></pre></td></tr></table></figure><p>上面的<code>birth</code>是可读写属性，而<code>age</code>就是一个<strong>只读</strong>属性，因为<code>age</code>可以根据<code>birth</code>和当前时间计算出来。</p><h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><p>decorator在目前最新的node LTS版本(8.11.3)和浏览器中都没有支持，需要借助babel转化为可支持的版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> npm install --save-dev babel-cli babel-preset-env</span><br></pre></td></tr></table></figure><p>在.babelrc中写入：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"presets"</span>: [<span class="string">"env"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>安装 decorators 插件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> npm install babel-plugin-transform-decorators-legacy --save-dev</span><br></pre></td></tr></table></figure><p>.babelrc</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"presets"</span>: [<span class="string">"env"</span>],</span><br><span class="line">  <span class="attr">"plugins"</span>: [<span class="string">"transform-decorators-legacy"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样babel的就配置完成了，babel-cli安装有<code>babel-node</code>和<code>babel</code>两个工具，babel执行编译，babel-node可以直接运行JS文件</p><p>JS中的修饰器只能用于类的修饰和类的方法的修饰</p><p>作用于类的装饰器</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isFruit</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">    target.isFruit = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br><span class="line">@isFruit</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(App.isFruit);    <span class="comment">// meow~~</span></span><br></pre></td></tr></table></figure><p>以上代码相当于</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cat = isFruit(<span class="function"><span class="keyword">function</span> <span class="title">Apple</span>(<span class="params"></span>) </span>&#123; ... &#125;);</span><br></pre></td></tr></table></figure><p>作用于类属性的装饰器</p><p>装饰器在作用于属性的时候，实际上就是通过<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" target="_blank" rel="noopener">Object.defineProperty()</a>来进行扩展和封装</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Math</span> </span>&#123;</span><br><span class="line">  @log</span><br><span class="line">  add(a, b) &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">target, name, descriptor</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> oldValue = descriptor.value;</span><br><span class="line"></span><br><span class="line">  descriptor.value = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Calling <span class="subst">$&#123;name&#125;</span> with`</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">return</span> oldValue.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> descriptor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> math = <span class="keyword">new</span> <span class="built_in">Math</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// passed parameters should get logged now</span></span><br><span class="line">math.add(<span class="number">2</span>, <span class="number">4</span>);</span><br></pre></td></tr></table></figure><p>装饰器接收三个参数，这三个参数和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" target="_blank" rel="noopener">Object.defineProperty()</a> 基本保持一致，分别表示：</p><ul><li>需要定义属性的对象 —— 被装饰的类</li><li>需定义或修改的属性的名字 —— 被装饰的属性名</li><li>将被定义或修改的属性的描述符 —— 属性的描述对象,,和 <code>Object.defineProperty()</code> 一样: <code>{value: [Function], writable: true, enumerable: false, configurable: true}</code></li></ul><h2 id="Golang"><a href="#Golang" class="headerlink" title="Golang"></a>Golang</h2><p>Golang利用Interface实现修饰模式如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// step1: 编写基础功能，刚开始不需要定义接口</span></span><br><span class="line"><span class="keyword">type</span> Base <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Base)</span> <span class="title">Call</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"base is called"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// step2: 将上面的方法声明为接口类型，基础功能中的 Call() 调用自动满足下面的接口</span></span><br><span class="line"><span class="keyword">type</span> DecoratorI <span class="keyword">interface</span> &#123;</span><br><span class="line">Call() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// step3: 编写新增功能，结构中保存接口类型的参数</span></span><br><span class="line"><span class="keyword">type</span> Decorator <span class="keyword">struct</span> &#123;</span><br><span class="line">derorator DecoratorI</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Decorator)</span> <span class="title">Call</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"decorator: "</span> + d.derorator.Call()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">base := &amp;Base&#123;&#125;</span><br><span class="line">fmt.Println(base.Call())</span><br><span class="line"></span><br><span class="line">decorator := Decorator&#123;base&#125;</span><br><span class="line">fmt.Println(decorator.Call())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;上个月使用Ts写Vue的项目时，分别尝试了基础构造器和类风格的写法，发现在类风格的写法中发现&lt;code&gt;vue-class-component&lt;/code&gt;通常与&lt;code&gt;vue-property-decorator&lt;/code&gt;一起使用，后者提供了很多vue的属性的修饰
      
    
    </summary>
    
    
      <category term="Python" scheme="https://blog.ache.fun/tags/Python/"/>
    
      <category term="Go" scheme="https://blog.ache.fun/tags/Go/"/>
    
      <category term="设计模式" scheme="https://blog.ache.fun/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="JavaScript" scheme="https://blog.ache.fun/tags/JavaScript/"/>
    
      <category term="TypeScript" scheme="https://blog.ache.fun/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>Scrapy工程化使用总结</title>
    <link href="https://blog.ache.fun/2018/07/29/Scrapy%E5%B7%A5%E7%A8%8B%E5%8C%96%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"/>
    <id>https://blog.ache.fun/2018/07/29/Scrapy工程化使用总结/</id>
    <published>2018-07-29T04:53:55.000Z</published>
    <updated>2018-08-19T13:01:28.885Z</updated>
    
    <content type="html"><![CDATA[<p>最近在做公司的一个项目涉及爬虫，语言习惯一开始想用golang解决，使用goquery，后发现，golang和goquery在处理多个站点后数据整合时，还需要做很多事情，在有限的时间内要快速完成，只能转移到生态更为成熟的<code>Scrapy</code>, 花了两周时间做了个多个站点的数据抓取整合的项目，其中有很多值得记录的地方，一并写下</p><h2 id="工作流"><a href="#工作流" class="headerlink" title="工作流"></a>工作流</h2><ol><li>使用<code>scrapy shell</code><a href="https://doc.scrapy.org/en/latest/topics/shell.html" target="_blank" rel="noopener">文档</a>设置User-Agent访问抓取目标页面</li><li>在shell中使用view(response)检查抓取的页面是否正确</li><li>使用<a href="https://doc.scrapy.org/en/latest/topics/selectors.html" target="_blank" rel="noopener">Selector</a>提取需要的数据</li><li>把提取规则复制到Spider中</li></ol><h2 id="运行多个Spider"><a href="#运行多个Spider" class="headerlink" title="运行多个Spider"></a>运行多个Spider</h2><p>在scrapy中，是使用命令行工具进行创建和控制项目，比如<code>scrapy startproject myproject</code>创建一个项目，<code>scrapy genspider [-t template] &lt;name&gt; &lt;domain&gt;</code>创建一个spider，更多的命令参考<a href="https://doc.scrapy.org/en/latest/topics/commands.html#controlling-projects" target="_blank" rel="noopener">官方文档</a>，运行爬虫时使用<code>scrapy crawl</code>只能运行一个spider而且是运行完后就停止，可项目需求是定时运行多个spider，显然一般的命令行不能满足要求，在文档的<code>SOLVING SPECIFIC PROBLEMS</code>部分的<a href="https://doc.scrapy.org/en/latest/topics/practices.html" target="_blank" rel="noopener">Common Practices</a>发现可以使用脚本运行多个spider，所在此文件控制spider的运行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"><span class="keyword">from</span> twisted.internet <span class="keyword">import</span> reactor</span><br><span class="line"><span class="keyword">from</span> scrapy.crawler <span class="keyword">import</span> CrawlerRunner</span><br><span class="line"><span class="keyword">from</span> scrapy.utils.log <span class="keyword">import</span> configure_logging</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySpider1</span><span class="params">(scrapy.Spider)</span>:</span></span><br><span class="line">    <span class="comment"># Your first spider definition</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySpider2</span><span class="params">(scrapy.Spider)</span>:</span></span><br><span class="line">    <span class="comment"># Your second spider definition</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">configure_logging()</span><br><span class="line">runner = CrawlerRunner()</span><br><span class="line">runner.crawl(MySpider1)</span><br><span class="line">runner.crawl(MySpider2)</span><br><span class="line">d = runner.join()</span><br><span class="line">d.addBoth(<span class="keyword">lambda</span> _: reactor.stop())</span><br></pre></td></tr></table></figure><h2 id="循环运行Spider"><a href="#循环运行Spider" class="headerlink" title="循环运行Spider"></a>循环运行Spider</h2><p>完成运行多个Spider后，还需要定时的循环运行，定时可以利用第三方库，但循环运行spider的时候报<code>twisted.internet.error.ReactorNotRestartable</code>错误，面向stackoverflow编程后发现在同一个进程中不能重新启动reactor，最后在多个进程中使用，还没弄懂为什么，后面需要补一下twisted</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"><span class="keyword">import</span> scrapy.crawler <span class="keyword">as</span> crawler</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Queue</span><br><span class="line"><span class="keyword">from</span> twisted.internet <span class="keyword">import</span> reactor</span><br><span class="line"></span><br><span class="line"><span class="comment"># your spider</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QuotesSpider</span><span class="params">(scrapy.Spider)</span>:</span></span><br><span class="line">    name = <span class="string">"quotes"</span></span><br><span class="line">    start_urls = [<span class="string">'http://quotes.toscrape.com/tag/humor/'</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(self, response)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> quote <span class="keyword">in</span> response.css(<span class="string">'div.quote'</span>):</span><br><span class="line">            print(quote.css(<span class="string">'span.text::text'</span>).extract_first())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># the wrapper to make it run more times</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_spider</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(q)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            runner = crawler.CrawlerRunner()</span><br><span class="line">            deferred = runner.crawl(QuotesSpider)</span><br><span class="line">            deferred.addBoth(<span class="keyword">lambda</span> _: reactor.stop())</span><br><span class="line">            reactor.run()</span><br><span class="line">            q.put(<span class="keyword">None</span>)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            q.put(e)</span><br><span class="line"></span><br><span class="line">    q = Queue()</span><br><span class="line">    p = Process(target=f, args=(q,))</span><br><span class="line">    p.start()</span><br><span class="line">    result = q.get()</span><br><span class="line">    p.join()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> result <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">        <span class="keyword">raise</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(<span class="string">'first run:'</span>)</span><br><span class="line">run_spider()</span><br><span class="line"></span><br><span class="line">print(<span class="string">'\nsecond run:'</span>)</span><br><span class="line">run_spider()</span><br></pre></td></tr></table></figure><h2 id="多个Spider指定对应的Item-Pipeline"><a href="#多个Spider指定对应的Item-Pipeline" class="headerlink" title="多个Spider指定对应的Item Pipeline"></a>多个Spider指定对应的Item Pipeline</h2><p>scrapy官方给的栗子定义Item Pipeline都是放在settings.py中，属于全局定义，运行每个spider都会生效。当需要给某个spider单独指定某个Item Pipelines而其他的spiser都不需要时，比如某个spider的自己清洗pipeline，只需在spider类中使用custom_setting属性，比如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooSpider</span><span class="params">(scrapy.Spider)</span>:</span></span><br><span class="line">    name = <span class="string">'foo'</span></span><br><span class="line">    allowed_domains = [<span class="string">'www.foo.com'</span>]</span><br><span class="line">    download_delay = <span class="number">5</span></span><br><span class="line">    custom_settings = &#123;</span><br><span class="line">        <span class="string">'ITEM_PIPELINES'</span>: &#123;</span><br><span class="line">            <span class="string">'example.pipelines.FooCleansingPipeline'</span>: <span class="number">300</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">'DOWNLOADER_MIDDLEWARES'</span>: &#123;</span><br><span class="line">            <span class="string">'example.middlewares.RandomUserAgentMiddleware'</span>: <span class="number">543</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>多种配置方式的优先级为命令行&gt;spider中的custom_settings&gt;项目settings&gt;各个命令的默认值&gt;全局默认值</p><h2 id="一个item-pipeline处理多个Item"><a href="#一个item-pipeline处理多个Item" class="headerlink" title="一个item pipeline处理多个Item"></a>一个item pipeline处理多个Item</h2><p>Spider生成多个Item时，在Spider中使用<code>yield item</code>都会传递到Item Pipeline，可需要分别对每个Item处理时，有个不优雅的解决办法，使用<code>isinstance</code>来判断进行处理</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooCleansingPipeline</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_item</span><span class="params">(self, item, spider)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> isinstance(item, Item1):</span><br><span class="line">            ...</span><br><span class="line">        <span class="keyword">elif</span> isinstance(item, Item2):</span><br><span class="line">...</span><br><span class="line">        <span class="keyword">return</span> item</span><br></pre></td></tr></table></figure><h2 id="设置中的数值"><a href="#设置中的数值" class="headerlink" title="设置中的数值"></a>设置中的数值</h2><p>0-1000，从小到大依次执行</p><h2 id="一个Item在多个parse函数中传递"><a href="#一个Item在多个parse函数中传递" class="headerlink" title="一个Item在多个parse函数中传递"></a>一个Item在多个parse函数中传递</h2><p>有时候一个Item可能要在多个页面才能抓取完整，这时候就需要把Item传递到多个页面的解析回调函数中，在yield下一次Request时，可以在meta字段中传递Item，代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(self, response)</span>:</span></span><br><span class="line"></span><br><span class="line">      item = Item()</span><br><span class="line">      ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">yield</span> scrapy.Request(</span><br><span class="line">    url=<span class="string">'xxx'</span>,</span><br><span class="line">    callback=self.parse_detail,</span><br><span class="line">    meta=&#123;</span><br><span class="line">        <span class="string">'item'</span>: Item,</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">parse_detail</span><span class="params">(self, response)</span>:</span></span><br><span class="line">      item = response.meta[<span class="string">'item'</span>]<span class="comment">#实际上是self.request.meta的快捷方式</span></span><br><span class="line">     ...</span><br><span class="line">  </span><br><span class="line">      <span class="keyword">yield</span> item</span><br></pre></td></tr></table></figure><h2 id="避免被禁止"><a href="#避免被禁止" class="headerlink" title="避免被禁止"></a>避免被禁止</h2><p>官方给的防止反爬的方法</p><ul><li><p>循环切换<code>User-Agent</code></p></li><li><p>禁用cookie(请参见<a href="https://doc.scrapy.org/en/latest/topics/downloader-middleware.html#std:setting-COOKIES_ENABLED" target="_blank" rel="noopener">COOKIES_ENABLED</a>)，因为有些站点可能使用cookie来发现bot行为。</p></li><li><p>使用下载延迟(download delays)(2s或更高)。参见<a href="https://doc.scrapy.org/en/latest/topics/settings.html#std:setting-DOWNLOAD_DELAY" target="_blank" rel="noopener">DOWNLOAD_DELAY</a>设置。</p></li><li><p>如果可能的话，使用谷歌缓存<a href="http://www.googleguide.com/cached_pages.html" target="_blank" rel="noopener">Google cache</a>获取页面，而不是直接访问站点</p></li><li><p>使用IP池循环切换IP。例如，免费的<a href="https://www.torproject.org/" target="_blank" rel="noopener">Tor project</a>或者像<a href="https://proxymesh.com/" target="_blank" rel="noopener">ProxyMesh</a>这样的付费服务。开源的另一种选择是<a href="https://scrapoxy.io/" target="_blank" rel="noopener">scrapoxy</a>，这是一个超级代理，您可以将自己的代理附加到其中。<em>就是设置一个IP池，使用代理，循环使用♻️</em></p></li><li><p>使用一个高度分布式的下行加载程序，可以在内部绕过禁止，因此您可以只关注解析干净的页面。这样下载的一个例子就是<a href="https://scrapinghub.com/crawlera?_ga=2.29623615.1463224097.1531630415-1657916130.1531387452" target="_blank" rel="noopener">Crawlera</a></p></li></ul><p>……..持续更新</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近在做公司的一个项目涉及爬虫，语言习惯一开始想用golang解决，使用goquery，后发现，golang和goquery在处理多个站点后数据整合时，还需要做很多事情，在有限的时间内要快速完成，只能转移到生态更为成熟的&lt;code&gt;Scrapy&lt;/code&gt;, 花了两周时间
      
    
    </summary>
    
    
      <category term="Python" scheme="https://blog.ache.fun/tags/Python/"/>
    
      <category term="爬虫" scheme="https://blog.ache.fun/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="Scrapy" scheme="https://blog.ache.fun/tags/Scrapy/"/>
    
  </entry>
  
  <entry>
    <title>我是阿扯，我现在慌的一批</title>
    <link href="https://blog.ache.fun/2018/07/22/%E6%88%91%E6%98%AF%E9%98%BF%E6%89%AF%EF%BC%8C%E6%88%91%E7%8E%B0%E5%9C%A8%E6%85%8C%E7%9A%84%E4%B8%80%E6%89%B9/"/>
    <id>https://blog.ache.fun/2018/07/22/我是阿扯，我现在慌的一批/</id>
    <published>2018-07-22T06:02:13.000Z</published>
    <updated>2018-08-18T15:52:36.836Z</updated>
    
    <content type="html"><![CDATA[<p>希望这是一个好的开始<br><a id="more"></a></p><p>和团队小伙伴一起约定以后要每周写一篇技术文章，每月写一篇读书笔记，差一篇请其他人每人喝一杯咖啡，这样的操作，让我慌的一批啊。<br><img src="/images/huang.jpg" alt=""><br>经过两天的折腾，在namesilo上买了域名，cloudflare上解析，最后在zoho上搞了域名邮箱，全套弄下来，第一年只要¥15不到，可以说是非常划算了。希望这是一个好的开始。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;希望这是一个好的开始&lt;br&gt;
    
    </summary>
    
    
      <category term="记录" scheme="https://blog.ache.fun/tags/%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
</feed>
