<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>远山淡影</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.ache.fun/"/>
  <updated>2018-08-19T15:40:53.059Z</updated>
  <id>https://blog.ache.fun/</id>
  
  <author>
    <name>阿扯</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>图灵机和图灵完备性</title>
    <link href="https://blog.ache.fun/2018/08/19/%E5%9B%BE%E7%81%B5%E6%9C%BA%E5%92%8C%E5%9B%BE%E7%81%B5%E5%AE%8C%E5%A4%87%E6%80%A7/"/>
    <id>https://blog.ache.fun/2018/08/19/图灵机和图灵完备性/</id>
    <published>2018-08-19T10:00:09.000Z</published>
    <updated>2018-08-19T15:40:53.059Z</updated>
    
    <content type="html"><![CDATA[<p>检索了很多资料之后，在coursera上发现了北京大学李戈老师的<a href="https://www.coursera.org/lecture/jisuanji-biancheng/cong-shu-xue-wei-ji-dao-tu-ling-ji-ieLnF" target="_blank" rel="noopener">计算导论与C语言基础</a>课程相当不错，这门课程很好的解释了图灵机的产生背景，构成，意义等。介于自己大学欠的太多基础理论，学习这门课程的同时在这里做下笔记。</p><h2 id="从数学危机到图灵机"><a href="#从数学危机到图灵机" class="headerlink" title="从数学危机到图灵机"></a>从数学危机到图灵机</h2><h5 id="第一次数学危机"><a href="#第一次数学危机" class="headerlink" title="第一次数学危机"></a>第一次数学危机</h5><p> 第一次数学危机是<strong>西帕索斯悖论</strong>，西帕索斯是公元前500年前著名的<strong>毕达哥拉斯学派</strong>代表人物毕达哥拉斯的学生。当时的毕达哥拉斯学派深信两点</p><ul><li>数是万物的本质，事物的性质是由某种数量关系决定的，万物按照一定的数量比例而构成和谐的秩序。</li><li>一切数均可表成整数或整数之比。</li></ul><p>但后来毕达哥拉斯自己又证明了<strong>勾股定理</strong>（西方叫做毕达哥拉斯定理），在这个定理的证明过程中，毕达哥拉斯发现某些直角三角形的三边之比是不能够用整数来表示的。这就很尴尬了，毕哥也慌了，这不是打我自己的脸嘛，他没有吭声，但他的学生西帕索斯也发现了这件事情，学生没有包袱啊，他就跟人们说，边长为1的正方形，它的对角线我们没法表示啊（根号2是无理数，无法用当时的整数之比来表示）。第一次数学危机由此产生，这个问题称之为<strong>西帕索斯悖论</strong>。</p><p>这次危机直到200年之后才得到缓解，当时有个人叫<strong>欧多克索斯</strong>，他建立起了一套完整的比例论，巧妙的避开了物无理数这一：“逻辑上的丑闻”，并保留住与之相关的一些结论，缓解了数学危机。但他的解决方式是借助<strong>几何方法</strong>，通过避免直接出现无理数实现的。他也推动了几何的发展。</p><p>这次危机真正的解决是在十九世纪下半叶，也就是实数确立之后，才得到真正的缓解。</p><h5 id="第二次数学危机"><a href="#第二次数学危机" class="headerlink" title="第二次数学危机"></a>第二次数学危机</h5><p>第二次数学危机是<strong>贝克莱</strong>悖论，与<strong>微积分</strong>有关，17世纪，<strong>牛顿</strong>和<strong>莱不尼兹</strong>在<strong>无穷小</strong>的分析之上各自建立了微积分理论。但当时很多人觉得这玩意儿有问题，最出名的就是<strong>贝克莱</strong>，他觉得无穷小量在牛顿的理论中“一会儿是零”，“一会儿又不是零”。贝克莱嘲笑无穷小量是“已死量的幽灵”<br><img src="/images/daoshu.jpeg" alt=""></p><p>主要体现在上图导数的推理过程中的dx作为分母是不应是零，但最后又当作零，这又是同一个推导过程。</p><ul><li>危机的缓解</li></ul><p>十九世纪七十年代，威尔斯、特斯拉、柯西、戴德金、康托尔等人建立了<strong>实数</strong>理论，在实数理论基础上，建立了极限论的基本定理，缓解了危机。但没有完美解决问题。</p><ul><li>新的问题</li></ul><p>魏尔斯特拉斯给出一个处处不可微的连续函数的例子，说明使用几何学的考虑重建的微积分基础是不可靠的，必须诉诸严格的概念和推理。于是推动了数学家们更深入的探讨数学分析的基础——实数论的问题，导致了<strong>集合论</strong>的诞生。</p><ul><li>集合论</li></ul><p>十九世纪下半叶，<strong>康托尔</strong>创立了著名的<strong>集合论</strong>，<strong>集合论对计算机理论而言是一个非常基础的理论</strong>，刚产生时，曾遭到许多人的猛烈攻击。后来人们发现，从自然数与康托尔集合论出发可建立起整个数学大厦。“一切数学成果可建立在集合论基础上”。庞加莱在1900年国际数学家大会上宣称，借助集合论概念，我们可以构建起整个数学大厦。今天我们可以说绝对的严格性已经达到了。</p><h5 id="第三次数学危机"><a href="#第三次数学危机" class="headerlink" title="第三次数学危机"></a>第三次数学危机</h5><p>就在庞加莱宣称集合论已经很严格的时候，<strong>罗素</strong>站出来提出了个通俗的问题</p><blockquote><p>塞尔维亚有一位理发师，他只给所有不给自己理发的人理发，不给那些给自己理发的人理发。问：理发师他要不要给自己理发呢？？？？</p></blockquote><p>这就是<strong>罗素悖论</strong>，即S由一切不是自身元素的集合所组成。罗素问：“S是否属于S呢？”，通过这个例子发现集合论也不是完美的。能不能找到一个更加完备的系统，从上面建立数学大厦呢？当然能！</p><p><strong>哥德尔</strong>1931年成功证明了</p><blockquote><p>任何一个数学系统，只要它是从有限的公理和基本概念中推导出来的，并且从中能推证出自然数系统，就可以在其中找到一个命题，对于它我们<strong>既没有办法证明</strong>，又没有办法推翻。</p></blockquote><p>后来人们把这个证明称为<strong>哥德尔不完备性定理</strong>，好好奇啊，这种证明是怎么证明出来的。</p><p>哥德尔不完全定理的证明结束了关于数学基础的争论，宣告了把数学彻底形式化的愿望是不可能实现的。不存在一个完美的系统。</p><h5 id="接下来的问题"><a href="#接下来的问题" class="headerlink" title="接下来的问题"></a>接下来的问题</h5><p>那么在一个系统中，有些问题是既不能被证真，也不能被证伪，有些问题则是可以被证真或被证伪，那么这两种问题的边界在哪里？又如何去判定到底一个问题是否真的有解？在计算机中，这个问题归结为<strong>可计算</strong>问题，也就是说假设有一个函数，它的定义域是D，值域是R，如果存在一个算法，对于D中任意给定的x，都能够计算出f(x)的值。存在一个算法，只要给出D中的一个x，我都能计算出f(x)的值，那么就称为这个函数f(x)是可以计算的，否则，它就是不可计算的。 </p><p>那如何判定一个问题是否可计算呢？</p><p>为这个<strong>计算</strong>建立一个数学模型。就是我们用一个数学模型来模拟这个计算，这个模型当然被称为计算模型，然后我们来证明凡是这个计算模型能够完成的任务，都是能够计算的任务，凡是这个计算模型不能够完成的任务，那么都是不可计算的任务。也就是说这个计算模型就像一个评价器一样，它能够评价出哪些问题是可计算的，哪些问题是不可计算的，我们现在需要寻找的就是这样一个模型。</p><p>然后重点来了，<strong>图灵</strong>就提出了这样一个模型，这个模型就是<strong>图灵机</strong></p><p>1936年，图灵在其著名的论文《论可计算数在判定问题中的应用》一文中提出了一种理想的计算机器的数学模型-图灵机（TuringMachine）</p><h2 id="图灵机的基本构成"><a href="#图灵机的基本构成" class="headerlink" title="图灵机的基本构成"></a>图灵机的基本构成</h2><h5 id="基本构成"><a href="#基本构成" class="headerlink" title="基本构成"></a>基本构成</h5><ul><li>一条存储带<ul><li>双向无限延长</li><li>上有一个个小方格</li><li>每个小方格可存储一个数字/字母</li></ul></li><li>一个控制器<ul><li>包含一个读写头，可以读、写、更改存储带上每一格的数字/字母</li><li>可以接受设定好的程序语句</li><li>可以存储当前自身的状态（有限个状态位）</li><li>可以变换自身的状态</li><li>可以沿着存储带一格一格地左移/右移</li></ul></li></ul><p>诺，就是这个样子<br><img src="/images/turing-machine.jpeg" alt=""></p><h5 id="图灵机的工作步骤"><a href="#图灵机的工作步骤" class="headerlink" title="图灵机的工作步骤"></a>图灵机的工作步骤</h5><ol><li>准备<ol><li>存储带上的符号初始化</li><li>控制器设置好自身当前状态</li><li>控制器置于起始位置</li><li>准备好工作程序</li></ol></li><li>反复执行以下工作直到停机<ol><li>读写头读出存储带上当前方格中的字母/数字</li><li>根据自身当前状态和所读到的字符，找到相应的程序语句</li><li>根据相应程序语句，做三个动作<ol><li>在当前存储带方格上写入一个相应的字母/数字</li><li>变更自身状态至新状态</li><li>读写头向左或向右移一步</li></ol></li></ol></li></ol><h2 id="图灵完备"><a href="#图灵完备" class="headerlink" title="图灵完备"></a>图灵完备</h2><p>在可计算性理论里，如果一系列<strong>操作数据的规则</strong>（如指令集、编程语言、细胞自动机）可以用来模拟以上的图灵机的全部功能时，那么它是图灵完备的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;检索了很多资料之后，在coursera上发现了北京大学李戈老师的&lt;a href=&quot;https://www.coursera.org/lecture/jisuanji-biancheng/cong-shu-xue-wei-ji-dao-tu-ling-ji-ieLnF&quot; ta
      
    
    </summary>
    
    
      <category term="计算机理论" scheme="https://blog.ache.fun/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>《万历十五年》读书笔记</title>
    <link href="https://blog.ache.fun/2018/08/16/%E3%80%8A%E4%B8%87%E5%8E%86%E5%8D%81%E4%BA%94%E5%B9%B4%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>https://blog.ache.fun/2018/08/16/《万历十五年》读书笔记/</id>
    <published>2018-08-16T03:25:19.000Z</published>
    <updated>2018-08-18T15:49:53.435Z</updated>
    
    <content type="html"><![CDATA[<p>不知何时开始，突然对历史感兴趣了，好像是因为实习时的一位上级，他在精通各种技术的同时，又能出口成章，引经据典，当时就被他的人格魅力所吸引。但又好像是因为上半年看的《人类简史》中的一段话：</p><blockquote><p>究竟为什么要学历史？历史不像是物理学或经济学，目的不在于做出准确预测。我们之所以研究历史，不是为了要知道未来，而是要拓展视野，要了解现在的种种绝非“自然”，也并非无可避免。</p></blockquote><p>喜欢历史的原因暂时无法考究，但历史本身却一直有料。</p><p>黄大师以明朝的几个人的生平来描述了万历皇帝时期社会的现状，把两千年来社会最大的症结归根于用道德代替法制。在这样的背景下，装腔作势的文官们统治着社会，压制着军事力量，不管是张居正、海瑞的极端进步，还是申时行、戚继光、万历的相对妥协，都解决不了根本的问题。这本书中不像历史电视剧那样的极端，其中没有绝对的善恶忠奸，也没有绝对的好坏，张居正、申时行、海瑞、戚继光、万历皇帝…他们也有自己的苦恼、野心、妥协和无可奈何。</p><p>用道德代替法制，对当时的朝廷来讲，最大的问题就是那些文官们不是真正的为民为社会，他们不去研究制度的改革，管理方法的演进，却整天忙于利用现存体制上的罅隙来满足自己的私欲，和制衡皇帝和文官，文官和文官这些关系。在这过程中却又以仁义道德相标榜。这也就让文官们的双重性格发展的越来越明显。面对这样的现状，张居正，海瑞的态度很激进，他们想要改变，但却无法撼动那些为了维护稳定关系的文官们，最后都没怎么好过。申时行，戚继光他们则看清了现实，在不影响各种关系平衡和利益的基础上小心谨慎的为这个朝代打着补丁，却依然徒劳无功。</p><p>以作者的收官一章来总结吧</p><blockquote><p>1587年，是为万历十五年，丁亥次岁，表面上似乎是四海升平，无事可记，实际上我们的大明帝国却已经走到了它发展的尽头。在这个时候，皇帝的励精图治或者宴安眈乐，首辅的独裁或者调和，高级将领的富于创造或者习于苟安，文官的廉洁奉公或者贪污舞弊，思想家的极端进步或者绝对保守，最后的结果，都是无分善恶，统统不能在事业上取得有意义的发展，有的身败，有的名裂，还有的人则身败而兼名裂。</p></blockquote><p>个人能力有限，少于写作，希望以后写起东西来能够越来越顺畅吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;不知何时开始，突然对历史感兴趣了，好像是因为实习时的一位上级，他在精通各种技术的同时，又能出口成章，引经据典，当时就被他的人格魅力所吸引。但又好像是因为上半年看的《人类简史》中的一段话：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;究竟为什么要学历史？历史不像是物理学或经济学，
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://blog.ache.fun/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>记PostgreSQL几种实用操作</title>
    <link href="https://blog.ache.fun/2018/08/11/%E8%AE%B0PostgreSQL%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%94%A8%E6%93%8D%E4%BD%9C/"/>
    <id>https://blog.ache.fun/2018/08/11/记PostgreSQL几种实用操作/</id>
    <published>2018-08-11T11:40:26.000Z</published>
    <updated>2018-08-18T15:08:18.468Z</updated>
    
    <content type="html"><![CDATA[<p>记录最近用到的几种实用的PostgreSQL技巧</p><h2 id="备份-恢复"><a href="#备份-恢复" class="headerlink" title="备份-恢复"></a>备份-恢复</h2><h5 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> pg_dump -U username -h hostname -p port databasename -t “table1,table2” -f filename</span><br></pre></td></tr></table></figure><p>简写</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> pg_dump -U postgres drupal7 &gt; drupal.bak</span><br></pre></td></tr></table></figure><p><a href="https://www.postgresql.org/docs/current/static/app-pgdump.html" target="_blank" rel="noopener">官网文档</a></p><h5 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a>恢复</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> psql -U username -h hostname -d desintationdb -p port -f dumpfilename.sql</span><br></pre></td></tr></table></figure><p>简写</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> psql -U postgres drupal7 &lt; drupal.bak</span><br></pre></td></tr></table></figure><p><a href="https://www.postgresql.org/docs/10/static/app-psql.html" target="_blank" rel="noopener">官方文档</a></p><h2 id="几个聚合函数"><a href="#几个聚合函数" class="headerlink" title="几个聚合函数"></a>几个聚合函数</h2><p>array_agg，官方有两种使用方法分别是</p><p><img src="/images/postgresql-array_agg.png" alt=""></p><p><code>string_agg(*expression*,*delimiter*)</code>,参数(<code>text</code>, <code>text</code>) or (<code>bytea</code>, <code>bytea</code>)，使用输入值串接成字符串，用分隔符分隔</p><p><code>json_agg</code>和arrat_agg功能类似，只不过聚合成了json数组</p><p><a href="https://www.postgresql.org/docs/10/static/functions-aggregate.html" target="_blank" rel="noopener">全部聚合函数文档</a></p><h2 id="去除重复的行"><a href="#去除重复的行" class="headerlink" title="去除重复的行"></a>去除重复的行</h2><p>比如这样的一张表</p><table><thead><tr><th style="text-align:center">id</th><th style="text-align:center">fruit</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">apple</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">apple</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">orange</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">orange</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">orange</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">Banana</td></tr></tbody></table><p>删除重复的记录使用<code>DELETE USING</code>表达式</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    basket a</span><br><span class="line">        <span class="keyword">USING</span> basket b</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    a.id &lt; b.id</span><br><span class="line">    <span class="keyword">AND</span> a.fruit = b.fruit;</span><br></pre></td></tr></table></figure><p><a href="https://www.postgresql.org/docs/10/static/sql-delete.html" target="_blank" rel="noopener">官方文档</a>中是这样描述的</p><blockquote><p>PostgreSQL lets you reference columns of other tables in the <code>WHERE</code> condition by specifying the other tables in the <code>USING</code> clause. For example, to delete all films produced by a given producer, one can do:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; DELETE FROM films USING producers</span><br><span class="line">&gt;   WHERE producer_id = producers.id AND producers.name = 'foo';</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>其中的原理应该是把filems join到producers中，然后在根据producers的条件删除。上面的例子把basket表join到自身，然后只保留id最大的那条记录，就达到了去重的目的。</p><h2 id="在golang中使用postgresql的array类型"><a href="#在golang中使用postgresql的array类型" class="headerlink" title="在golang中使用postgresql的array类型"></a>在golang中使用postgresql的array类型</h2><p>使用<code>github.com/lib/pq</code>库其中有多种array类型，几种常见的如下</p><ul><li><p>Float64Array </p></li><li><p>StringArray</p></li><li><p>Int64Array</p><p>……</p></li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  ...</span><br><span class="line">  <span class="string">"github.com/lib/pq"</span></span><br><span class="line">  ...</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="keyword">type</span> Block <span class="keyword">struct</span> &#123;</span><br><span class="line">gorm.Model</span><br><span class="line">        .....</span><br><span class="line">Tx                pq.StringArray <span class="string">`gorm:"type:varchar(100)[]"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更多类型参见<a href="https://godoc.org/github.com/lib/pq#pkg-index" target="_blank" rel="noopener">官方文档</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;记录最近用到的几种实用的PostgreSQL技巧&lt;/p&gt;
&lt;h2 id=&quot;备份-恢复&quot;&gt;&lt;a href=&quot;#备份-恢复&quot; class=&quot;headerlink&quot; title=&quot;备份-恢复&quot;&gt;&lt;/a&gt;备份-恢复&lt;/h2&gt;&lt;h5 id=&quot;备份&quot;&gt;&lt;a href=&quot;#备份&quot; cla
      
    
    </summary>
    
    
      <category term="数据库" scheme="https://blog.ache.fun/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="PostgreSQL" scheme="https://blog.ache.fun/tags/PostgreSQL/"/>
    
  </entry>
  
  <entry>
    <title>几种语言中的装饰器</title>
    <link href="https://blog.ache.fun/2018/08/04/%E5%87%A0%E7%A7%8D%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E8%A3%85%E9%A5%B0%E5%99%A8/"/>
    <id>https://blog.ache.fun/2018/08/04/几种语言中的装饰器/</id>
    <published>2018-08-04T07:23:48.000Z</published>
    <updated>2018-08-18T15:08:30.779Z</updated>
    
    <content type="html"><![CDATA[<p>上个月使用Ts写Vue的项目时，分别尝试了基础构造器和类风格的写法，发现在类风格的写法中发现<code>vue-class-component</code>通常与<code>vue-property-decorator</code>一起使用，后者提供了很多vue的属性的修饰器。之后使用python的<code>scrapy</code>写项目时，又发现了<code>Scrapy</code>中也使用了修饰器，你说巧不巧，在上周写的一个node后端项目中又发现了修饰器的存在，这东西在短短一个月内，在我的眼前不断的刷新着存在感，看来确实需要和它确认下眼神。这里分别把Python，JS，TS，几种语言的修饰器使用简单的对比下</p><h2 id="从python说起"><a href="#从python说起" class="headerlink" title="从python说起"></a>从python说起</h2><blockquote><p>A Python decorator is a function that takes another function, extending the behavior of the latter function without explicitly modifying it.</p></blockquote><p>一个简单的装饰器</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'i am bar'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">use_logging_with_decorator</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        logging.warn(<span class="string">'%s is running'</span>, func.__name__)</span><br><span class="line">        <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line">bar = use_logging_with_decorator(bar)</span><br></pre></td></tr></table></figure><p>原理无非是把真正的业务函数包裹到一个装饰函数中，然后结合语法糖食用就变成了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@use_logging_with_decorator</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"i am bar"</span>)</span><br></pre></td></tr></table></figure><p>装饰器 decorator 接收一个参数，也就是我们被装饰的目标方法，处理完扩展的内容以后再返回一个方法，供以后调用，同时也失去了对原方法对象的访问。当我们对某个应用了装饰以后，其实就改变了被装饰方法的入口引用，使其重新指向了装饰器返回的方法的入口点，从而来实现我们对原函数的扩展、修改等操作。</p><p>使用装饰器后，原函数的元信息变成了装饰器的，把装饰器的元信息修改成原函数的，使用<code>functools</code>中的wraps</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">logged</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="meta">    @wraps(func)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">with_logging</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> func.__name__ + <span class="string">" was called"</span></span><br><span class="line">        <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> with_logging</span><br><span class="line"></span><br><span class="line"><span class="meta">@logged</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="string">"""does some math"""</span></span><br><span class="line">    <span class="keyword">return</span> x + x * x</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> f.__name__  <span class="comment"># prints 'f'</span></span><br><span class="line"><span class="keyword">print</span> f.__doc__   <span class="comment"># prints 'does some math'</span></span><br></pre></td></tr></table></figure><h4 id="python内置的装饰器"><a href="#python内置的装饰器" class="headerlink" title="python内置的装饰器"></a>python内置的装饰器</h4><p>@classmethod</p><p>classmethod 修饰符对应的函数不需要实例化，不需要 self 参数，但第一个参数需要是表示自身类的 cls 参数，可以来调用类的属性，类的方法，实例化对象等。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line">    bar = <span class="number">1</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func1</span><span class="params">(self)</span>:</span>  </span><br><span class="line">        <span class="keyword">print</span> (<span class="string">'foo'</span>) </span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func2</span><span class="params">(cls)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> (<span class="string">'func2'</span>)</span><br><span class="line">        <span class="keyword">print</span> (cls.bar)</span><br><span class="line">        cls().func1()   <span class="comment"># 调用 foo 方法</span></span><br><span class="line"> </span><br><span class="line">A.func2()               <span class="comment"># 不需要实例化</span></span><br></pre></td></tr></table></figure><p>@ staticmethod</p><p>python staticmethod 返回函数的静态方法。</p><p>该方法不强制要求传递参数，如下声明一个静态方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">'runoob'</span>);</span><br><span class="line"> </span><br><span class="line">C.f();          <span class="comment"># 静态方法无需实例化</span></span><br><span class="line">cobj = C()</span><br><span class="line">cobj.f()        <span class="comment"># 也可以实例化后调用</span></span><br></pre></td></tr></table></figure><p>@property</p><p><code>@property</code>装饰器就是负责把一个方法变成属性调用的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">score</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._score</span><br><span class="line"></span><br><span class="line"><span class="meta">    @score.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">score</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> isinstance(value, int):</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'score must be an integer!'</span>)</span><br><span class="line">        <span class="keyword">if</span> value &lt; <span class="number">0</span> <span class="keyword">or</span> value &gt; <span class="number">100</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'score must between 0 ~ 100!'</span>)</span><br><span class="line">        self._score = value</span><br></pre></td></tr></table></figure><p>把一个getter方法变成属性，只需要加上<code>@property</code>就可以了，此时，<code>@property</code>本身又创建了另一个装饰器<a href="mailto:`@score.setter" target="_blank" rel="noopener">`@score.setter</a>`，负责把一个setter方法变成属性赋值，于是，我们就拥有一个可控的属性操作：</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = Student()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.score = <span class="number">60</span> <span class="comment"># OK，实际转化为s.set_score(60)</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.score <span class="comment"># OK，实际转化为s.get_score()</span></span><br><span class="line"><span class="number">60</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.score = <span class="number">9999</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  ...</span><br><span class="line">ValueError: score must between <span class="number">0</span> ~ <span class="number">100</span>!</span><br></pre></td></tr></table></figure><p>当某个属性不是直接暴露，而是通过getter和setter方法来实现的时候，就可以使用@property</p><p>还可以定义只读属性，只定义getter方法，不定义setter方法就是一个只读属性：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">birth</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._birth</span><br><span class="line"></span><br><span class="line"><span class="meta">    @birth.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">birth</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        self._birth = value</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">age</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">2018</span> - self._birth</span><br></pre></td></tr></table></figure><p>上面的<code>birth</code>是可读写属性，而<code>age</code>就是一个<strong>只读</strong>属性，因为<code>age</code>可以根据<code>birth</code>和当前时间计算出来。</p><h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><p>decorator在目前最新的node LTS版本(8.11.3)和浏览器中都没有支持，需要借助babel转化为可支持的版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> npm install --save-dev babel-cli babel-preset-env</span><br></pre></td></tr></table></figure><p>在.babelrc中写入：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"presets"</span>: [<span class="string">"env"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>安装 decorators 插件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> npm install babel-plugin-transform-decorators-legacy --save-dev</span><br></pre></td></tr></table></figure><p>.babelrc</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"presets"</span>: [<span class="string">"env"</span>],</span><br><span class="line">  <span class="attr">"plugins"</span>: [<span class="string">"transform-decorators-legacy"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样babel的就配置完成了，babel-cli安装有<code>babel-node</code>和<code>babel</code>两个工具，babel执行编译，babel-node可以直接运行JS文件</p><p>JS中的修饰器只能用于类的修饰和类的方法的修饰</p><p>作用于类的装饰器</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isFruit</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">    target.isFruit = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br><span class="line">@isFruit</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(App.isFruit);    <span class="comment">// meow~~</span></span><br></pre></td></tr></table></figure><p>以上代码相当于</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cat = isFruit(<span class="function"><span class="keyword">function</span> <span class="title">Apple</span>(<span class="params"></span>) </span>&#123; ... &#125;);</span><br></pre></td></tr></table></figure><p>作用于类属性的装饰器</p><p>装饰器在作用于属性的时候，实际上就是通过<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" target="_blank" rel="noopener">Object.defineProperty()</a>来进行扩展和封装</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Math</span> </span>&#123;</span><br><span class="line">  @log</span><br><span class="line">  add(a, b) &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">target, name, descriptor</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> oldValue = descriptor.value;</span><br><span class="line"></span><br><span class="line">  descriptor.value = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Calling <span class="subst">$&#123;name&#125;</span> with`</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">return</span> oldValue.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> descriptor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> math = <span class="keyword">new</span> <span class="built_in">Math</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// passed parameters should get logged now</span></span><br><span class="line">math.add(<span class="number">2</span>, <span class="number">4</span>);</span><br></pre></td></tr></table></figure><p>装饰器接收三个参数，这三个参数和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" target="_blank" rel="noopener">Object.defineProperty()</a> 基本保持一致，分别表示：</p><ul><li>需要定义属性的对象 —— 被装饰的类</li><li>需定义或修改的属性的名字 —— 被装饰的属性名</li><li>将被定义或修改的属性的描述符 —— 属性的描述对象,,和 <code>Object.defineProperty()</code> 一样: <code>{value: [Function], writable: true, enumerable: false, configurable: true}</code></li></ul><h2 id="Golang"><a href="#Golang" class="headerlink" title="Golang"></a>Golang</h2><p>Golang利用Interface实现修饰模式如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// step1: 编写基础功能，刚开始不需要定义接口</span></span><br><span class="line"><span class="keyword">type</span> Base <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Base)</span> <span class="title">Call</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"base is called"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// step2: 将上面的方法声明为接口类型，基础功能中的 Call() 调用自动满足下面的接口</span></span><br><span class="line"><span class="keyword">type</span> DecoratorI <span class="keyword">interface</span> &#123;</span><br><span class="line">Call() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// step3: 编写新增功能，结构中保存接口类型的参数</span></span><br><span class="line"><span class="keyword">type</span> Decorator <span class="keyword">struct</span> &#123;</span><br><span class="line">derorator DecoratorI</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Decorator)</span> <span class="title">Call</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"decorator: "</span> + d.derorator.Call()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">base := &amp;Base&#123;&#125;</span><br><span class="line">fmt.Println(base.Call())</span><br><span class="line"></span><br><span class="line">decorator := Decorator&#123;base&#125;</span><br><span class="line">fmt.Println(decorator.Call())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;上个月使用Ts写Vue的项目时，分别尝试了基础构造器和类风格的写法，发现在类风格的写法中发现&lt;code&gt;vue-class-component&lt;/code&gt;通常与&lt;code&gt;vue-property-decorator&lt;/code&gt;一起使用，后者提供了很多vue的属性的修饰
      
    
    </summary>
    
    
      <category term="设计模式" scheme="https://blog.ache.fun/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Python" scheme="https://blog.ache.fun/tags/Python/"/>
    
      <category term="JavaScript" scheme="https://blog.ache.fun/tags/JavaScript/"/>
    
      <category term="TypeScript" scheme="https://blog.ache.fun/tags/TypeScript/"/>
    
      <category term="Go" scheme="https://blog.ache.fun/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Scrapy工程化使用总结</title>
    <link href="https://blog.ache.fun/2018/07/29/Scrapy%E5%B7%A5%E7%A8%8B%E5%8C%96%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"/>
    <id>https://blog.ache.fun/2018/07/29/Scrapy工程化使用总结/</id>
    <published>2018-07-29T04:53:55.000Z</published>
    <updated>2018-08-19T13:01:28.885Z</updated>
    
    <content type="html"><![CDATA[<p>最近在做公司的一个项目涉及爬虫，语言习惯一开始想用golang解决，使用goquery，后发现，golang和goquery在处理多个站点后数据整合时，还需要做很多事情，在有限的时间内要快速完成，只能转移到生态更为成熟的<code>Scrapy</code>, 花了两周时间做了个多个站点的数据抓取整合的项目，其中有很多值得记录的地方，一并写下</p><h2 id="工作流"><a href="#工作流" class="headerlink" title="工作流"></a>工作流</h2><ol><li>使用<code>scrapy shell</code><a href="https://doc.scrapy.org/en/latest/topics/shell.html" target="_blank" rel="noopener">文档</a>设置User-Agent访问抓取目标页面</li><li>在shell中使用view(response)检查抓取的页面是否正确</li><li>使用<a href="https://doc.scrapy.org/en/latest/topics/selectors.html" target="_blank" rel="noopener">Selector</a>提取需要的数据</li><li>把提取规则复制到Spider中</li></ol><h2 id="运行多个Spider"><a href="#运行多个Spider" class="headerlink" title="运行多个Spider"></a>运行多个Spider</h2><p>在scrapy中，是使用命令行工具进行创建和控制项目，比如<code>scrapy startproject myproject</code>创建一个项目，<code>scrapy genspider [-t template] &lt;name&gt; &lt;domain&gt;</code>创建一个spider，更多的命令参考<a href="https://doc.scrapy.org/en/latest/topics/commands.html#controlling-projects" target="_blank" rel="noopener">官方文档</a>，运行爬虫时使用<code>scrapy crawl</code>只能运行一个spider而且是运行完后就停止，可项目需求是定时运行多个spider，显然一般的命令行不能满足要求，在文档的<code>SOLVING SPECIFIC PROBLEMS</code>部分的<a href="https://doc.scrapy.org/en/latest/topics/practices.html" target="_blank" rel="noopener">Common Practices</a>发现可以使用脚本运行多个spider，所在此文件控制spider的运行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"><span class="keyword">from</span> twisted.internet <span class="keyword">import</span> reactor</span><br><span class="line"><span class="keyword">from</span> scrapy.crawler <span class="keyword">import</span> CrawlerRunner</span><br><span class="line"><span class="keyword">from</span> scrapy.utils.log <span class="keyword">import</span> configure_logging</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySpider1</span><span class="params">(scrapy.Spider)</span>:</span></span><br><span class="line">    <span class="comment"># Your first spider definition</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySpider2</span><span class="params">(scrapy.Spider)</span>:</span></span><br><span class="line">    <span class="comment"># Your second spider definition</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">configure_logging()</span><br><span class="line">runner = CrawlerRunner()</span><br><span class="line">runner.crawl(MySpider1)</span><br><span class="line">runner.crawl(MySpider2)</span><br><span class="line">d = runner.join()</span><br><span class="line">d.addBoth(<span class="keyword">lambda</span> _: reactor.stop())</span><br></pre></td></tr></table></figure><h2 id="循环运行Spider"><a href="#循环运行Spider" class="headerlink" title="循环运行Spider"></a>循环运行Spider</h2><p>完成运行多个Spider后，还需要定时的循环运行，定时可以利用第三方库，但循环运行spider的时候报<code>twisted.internet.error.ReactorNotRestartable</code>错误，面向stackoverflow编程后发现在同一个进程中不能重新启动reactor，最后在多个进程中使用，还没弄懂为什么，后面需要补一下twisted</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"><span class="keyword">import</span> scrapy.crawler <span class="keyword">as</span> crawler</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Queue</span><br><span class="line"><span class="keyword">from</span> twisted.internet <span class="keyword">import</span> reactor</span><br><span class="line"></span><br><span class="line"><span class="comment"># your spider</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QuotesSpider</span><span class="params">(scrapy.Spider)</span>:</span></span><br><span class="line">    name = <span class="string">"quotes"</span></span><br><span class="line">    start_urls = [<span class="string">'http://quotes.toscrape.com/tag/humor/'</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(self, response)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> quote <span class="keyword">in</span> response.css(<span class="string">'div.quote'</span>):</span><br><span class="line">            print(quote.css(<span class="string">'span.text::text'</span>).extract_first())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># the wrapper to make it run more times</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_spider</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(q)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            runner = crawler.CrawlerRunner()</span><br><span class="line">            deferred = runner.crawl(QuotesSpider)</span><br><span class="line">            deferred.addBoth(<span class="keyword">lambda</span> _: reactor.stop())</span><br><span class="line">            reactor.run()</span><br><span class="line">            q.put(<span class="keyword">None</span>)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            q.put(e)</span><br><span class="line"></span><br><span class="line">    q = Queue()</span><br><span class="line">    p = Process(target=f, args=(q,))</span><br><span class="line">    p.start()</span><br><span class="line">    result = q.get()</span><br><span class="line">    p.join()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> result <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">        <span class="keyword">raise</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(<span class="string">'first run:'</span>)</span><br><span class="line">run_spider()</span><br><span class="line"></span><br><span class="line">print(<span class="string">'\nsecond run:'</span>)</span><br><span class="line">run_spider()</span><br></pre></td></tr></table></figure><h2 id="多个Spider指定对应的Item-Pipeline"><a href="#多个Spider指定对应的Item-Pipeline" class="headerlink" title="多个Spider指定对应的Item Pipeline"></a>多个Spider指定对应的Item Pipeline</h2><p>scrapy官方给的栗子定义Item Pipeline都是放在settings.py中，属于全局定义，运行每个spider都会生效。当需要给某个spider单独指定某个Item Pipelines而其他的spiser都不需要时，比如某个spider的自己清洗pipeline，只需在spider类中使用custom_setting属性，比如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooSpider</span><span class="params">(scrapy.Spider)</span>:</span></span><br><span class="line">    name = <span class="string">'foo'</span></span><br><span class="line">    allowed_domains = [<span class="string">'www.foo.com'</span>]</span><br><span class="line">    download_delay = <span class="number">5</span></span><br><span class="line">    custom_settings = &#123;</span><br><span class="line">        <span class="string">'ITEM_PIPELINES'</span>: &#123;</span><br><span class="line">            <span class="string">'example.pipelines.FooCleansingPipeline'</span>: <span class="number">300</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">'DOWNLOADER_MIDDLEWARES'</span>: &#123;</span><br><span class="line">            <span class="string">'example.middlewares.RandomUserAgentMiddleware'</span>: <span class="number">543</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>多种配置方式的优先级为命令行&gt;spider中的custom_settings&gt;项目settings&gt;各个命令的默认值&gt;全局默认值</p><h2 id="一个item-pipeline处理多个Item"><a href="#一个item-pipeline处理多个Item" class="headerlink" title="一个item pipeline处理多个Item"></a>一个item pipeline处理多个Item</h2><p>Spider生成多个Item时，在Spider中使用<code>yield item</code>都会传递到Item Pipeline，可需要分别对每个Item处理时，有个不优雅的解决办法，使用<code>isinstance</code>来判断进行处理</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooCleansingPipeline</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_item</span><span class="params">(self, item, spider)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> isinstance(item, Item1):</span><br><span class="line">            ...</span><br><span class="line">        <span class="keyword">elif</span> isinstance(item, Item2):</span><br><span class="line">...</span><br><span class="line">        <span class="keyword">return</span> item</span><br></pre></td></tr></table></figure><h2 id="设置中的数值"><a href="#设置中的数值" class="headerlink" title="设置中的数值"></a>设置中的数值</h2><p>0-1000，从小到大依次执行</p><h2 id="一个Item在多个parse函数中传递"><a href="#一个Item在多个parse函数中传递" class="headerlink" title="一个Item在多个parse函数中传递"></a>一个Item在多个parse函数中传递</h2><p>有时候一个Item可能要在多个页面才能抓取完整，这时候就需要把Item传递到多个页面的解析回调函数中，在yield下一次Request时，可以在meta字段中传递Item，代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(self, response)</span>:</span></span><br><span class="line"></span><br><span class="line">      item = Item()</span><br><span class="line">      ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">yield</span> scrapy.Request(</span><br><span class="line">    url=<span class="string">'xxx'</span>,</span><br><span class="line">    callback=self.parse_detail,</span><br><span class="line">    meta=&#123;</span><br><span class="line">        <span class="string">'item'</span>: Item,</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">parse_detail</span><span class="params">(self, response)</span>:</span></span><br><span class="line">      item = response.meta[<span class="string">'item'</span>]<span class="comment">#实际上是self.request.meta的快捷方式</span></span><br><span class="line">     ...</span><br><span class="line">  </span><br><span class="line">      <span class="keyword">yield</span> item</span><br></pre></td></tr></table></figure><h2 id="避免被禁止"><a href="#避免被禁止" class="headerlink" title="避免被禁止"></a>避免被禁止</h2><p>官方给的防止反爬的方法</p><ul><li><p>循环切换<code>User-Agent</code></p></li><li><p>禁用cookie(请参见<a href="https://doc.scrapy.org/en/latest/topics/downloader-middleware.html#std:setting-COOKIES_ENABLED" target="_blank" rel="noopener">COOKIES_ENABLED</a>)，因为有些站点可能使用cookie来发现bot行为。</p></li><li><p>使用下载延迟(download delays)(2s或更高)。参见<a href="https://doc.scrapy.org/en/latest/topics/settings.html#std:setting-DOWNLOAD_DELAY" target="_blank" rel="noopener">DOWNLOAD_DELAY</a>设置。</p></li><li><p>如果可能的话，使用谷歌缓存<a href="http://www.googleguide.com/cached_pages.html" target="_blank" rel="noopener">Google cache</a>获取页面，而不是直接访问站点</p></li><li><p>使用IP池循环切换IP。例如，免费的<a href="https://www.torproject.org/" target="_blank" rel="noopener">Tor project</a>或者像<a href="https://proxymesh.com/" target="_blank" rel="noopener">ProxyMesh</a>这样的付费服务。开源的另一种选择是<a href="https://scrapoxy.io/" target="_blank" rel="noopener">scrapoxy</a>，这是一个超级代理，您可以将自己的代理附加到其中。<em>就是设置一个IP池，使用代理，循环使用♻️</em></p></li><li><p>使用一个高度分布式的下行加载程序，可以在内部绕过禁止，因此您可以只关注解析干净的页面。这样下载的一个例子就是<a href="https://scrapinghub.com/crawlera?_ga=2.29623615.1463224097.1531630415-1657916130.1531387452" target="_blank" rel="noopener">Crawlera</a></p></li></ul><p>……..持续更新</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近在做公司的一个项目涉及爬虫，语言习惯一开始想用golang解决，使用goquery，后发现，golang和goquery在处理多个站点后数据整合时，还需要做很多事情，在有限的时间内要快速完成，只能转移到生态更为成熟的&lt;code&gt;Scrapy&lt;/code&gt;, 花了两周时间
      
    
    </summary>
    
    
      <category term="Python" scheme="https://blog.ache.fun/tags/Python/"/>
    
      <category term="爬虫" scheme="https://blog.ache.fun/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="Scrapy" scheme="https://blog.ache.fun/tags/Scrapy/"/>
    
  </entry>
  
  <entry>
    <title>我是阿扯，我现在慌的一批</title>
    <link href="https://blog.ache.fun/2018/07/22/%E6%88%91%E6%98%AF%E9%98%BF%E6%89%AF%EF%BC%8C%E6%88%91%E7%8E%B0%E5%9C%A8%E6%85%8C%E7%9A%84%E4%B8%80%E6%89%B9/"/>
    <id>https://blog.ache.fun/2018/07/22/我是阿扯，我现在慌的一批/</id>
    <published>2018-07-22T06:02:13.000Z</published>
    <updated>2018-08-18T15:52:36.836Z</updated>
    
    <content type="html"><![CDATA[<p>希望这是一个好的开始<br><a id="more"></a></p><p>和团队小伙伴一起约定以后要每周写一篇技术文章，每月写一篇读书笔记，差一篇请其他人每人喝一杯咖啡，这样的操作，让我慌的一批啊。<br><img src="/images/huang.jpg" alt=""><br>经过两天的折腾，在namesilo上买了域名，cloudflare上解析，最后在zoho上搞了域名邮箱，全套弄下来，第一年只要¥15不到，可以说是非常划算了。希望这是一个好的开始。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;希望这是一个好的开始&lt;br&gt;
    
    </summary>
    
    
      <category term="记录" scheme="https://blog.ache.fun/tags/%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
</feed>
