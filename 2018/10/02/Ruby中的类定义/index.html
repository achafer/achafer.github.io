<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title>Ruby中的类 · 远山淡影</title><meta name="description" content="Ruby中的类 - 阿扯"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="/css/gandalfr.css"><link rel="stylesheet" href="https://highlightjs.org/static/demo/styles/solarized-light.css"><link rel="search" type="application/opensearchdescription+xml" href="https://blog.ache.fun/atom.xml" title="远山淡影"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/lion.jpg" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="/links/" target="_self" class="nav-list-link">LINKS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Ruby中的类</h1><div class="tags"><a href="/tags/Ruby/" class="tag-title">#Ruby</a></div><div class="post-info">Oct 2, 2018</div><div class="post-content"><p>最近因工作需要学习Ruby，被Ruby的优雅和灵活所吸引，阅读《Ruby元编程》的时候更是酣畅淋漓，想吃了炫迈一样，第五章类定义是本书中的核心部分，在这里记录下相本章相关笔记。</p>
<h3 id="类定义"><a href="#类定义" class="headerlink" title="类定义"></a>类定义</h3><h5 id="类定义-1"><a href="#类定义-1" class="headerlink" title="类定义"></a>类定义</h5><p>定义类不止是定义方法。其实，可以在类定义中放入任何代码</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span><br><span class="line">    puts <span class="string">"Hello"</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">&lt; Hello</span><br></pre></td></tr></table></figure>
<p>就像方法和块一样，类定义也会返回最后一条语句的值</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">result = <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span><br><span class="line">    <span class="keyword">self</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">result <span class="comment"># =&gt; MyClass</span></span><br></pre></td></tr></table></figure>
<p>定义类（或模块）时，类本身充当当前对象self的角色。类和模块也是对象，所以类也可以充当self。</p>
<h5 id="当前类"><a href="#当前类" class="headerlink" title="当前类"></a>当前类</h5><ul>
<li><p>Ruby解释器总是追踪当前类(或模块)的引用。所有使用<code>def</code>定义的方法成为当前类的实例方法。</p>
</li>
<li><p>在类定义中，当前类就是self——正在定义的类</p>
</li>
<li><p>可以使用class_eval（或module_eval）方法打开一个已存在的类的引用</p>
</li>
</ul>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_method_to</span><span class="params">(a_class)</span></span></span><br><span class="line">    a_class.class_eval <span class="keyword">do</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">m</span>;</span> <span class="string">'Hello!'</span>; <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">add_method_to String</span><br><span class="line"></span><br><span class="line"><span class="string">"abc"</span>.m</span><br></pre></td></tr></table></figure>
<p>instance_eval和class_eval方法的选择：通常使用instalce_eval/class_eval方法打开非类的对象；用class_eval方法打开类的定义，然后用def定义方法。如果打开的对象也是类（或模块），只修改self而且并不关心它是不是一个类，那么instance_eval就很好；如果使用<strong>打开类</strong>技巧修改类，使用<code>class_eval</code>方法更好。</p>
<h5 id="类实例变量"><a href="#类实例变量" class="headerlink" title="类实例变量"></a>类实例变量</h5><p>类的实例变量不同于类的对象的实例变量。例如</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span><br><span class="line">    <span class="comment"># 这个my_var 定义于MyClass充当self的时刻，它是MyClass的实例变量，也就是类实例变量。</span></span><br><span class="line">    @my_var = <span class="number">1</span></span><br><span class="line">    <span class="comment"># 同样类实例变量</span></span><br><span class="line">   	<span class="function"><span class="keyword">def</span> <span class="title">self</span>.<span class="title">read</span>;</span> @my_var; <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">     <span class="comment"># 这个my_var 定义于obj充当self的时刻，它是obj的实例变量</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">write</span>;</span> @my_var = <span class="number">2</span>; <span class="keyword">end</span> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">read</span>;</span> @my_var; <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">obj = MyClass.new</span><br><span class="line">obj.read  <span class="comment"># =&gt; nil</span></span><br><span class="line">obj.write</span><br><span class="line">obj.read <span class="comment"># =&gt; 2</span></span><br><span class="line">MyClass.read <span class="comment"># =&gt; 1</span></span><br></pre></td></tr></table></figure>
<h3 id="单件方法"><a href="#单件方法" class="headerlink" title="单件方法"></a>单件方法</h3><h5 id="使用单件方法"><a href="#使用单件方法" class="headerlink" title="使用单件方法"></a>使用单件方法</h5><p>Ruby允许给单个对象增加一个方法。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">str = <span class="string">"just a regular string"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">str</span>.<span class="title">title?</span></span></span><br><span class="line">    <span class="keyword">self</span>.upcase == <span class="keyword">self</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">str.title?				    <span class="comment"># =&gt; fasle</span></span><br><span class="line">str.methods.grep(<span class="regexp">/title?/</span>)	<span class="comment"># =&gt; [:title?]</span></span><br><span class="line">str.singleton_methods       <span class="comment"># =&gt; [:title?]</span></span><br></pre></td></tr></table></figure>
<p>只对单个对象生效的方法称为<strong>单件方法</strong>(Singleton Method)。可以直接 <code>def obj.singleton_method</code>来定义单件方法，也可以使用<code>Object#define_singleton_method</code>方法来定义。</p>
<h5 id="类方法的真相"><a href="#类方法的真相" class="headerlink" title="类方法的真相"></a>类方法的真相</h5><p>类也是对象，而类名只是常量。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 由变量引用的对象上调用方法</span></span><br><span class="line">an_object.a_method</span><br><span class="line"></span><br><span class="line"><span class="comment"># 一个由常量引用的对象（也是一个类）上调用方法。和上面语法完全一样</span></span><br><span class="line">AClass.a_class_method</span><br></pre></td></tr></table></figure>
<p><strong>类方法的实质上是一个类的单件方法</strong></p>
<h5 id="类宏"><a href="#类宏" class="headerlink" title="类宏"></a>类宏</h5><p>Ruby对象没有属性。如果要实现类似属性的东西，需要定义两个方法。不过Module类中定义了三个访问器：<code>attr_reader</code>、<code>attr_writer</code>和<code>attr_accessor</code>，像这样的方法称为<strong>类宏</strong>(Class Macro)。类宏看起来很像关键字，但是它们只是普通的方法，只不过可以用在类定义里。</p>
<h3 id="单件类"><a href="#单件类" class="headerlink" title="单件类"></a>单件类</h3><p>Ruby查找方法时先向右一步进入接收者的类，然后在向上查找，那么单件方法存放在哪里呢？</p>
<p>向对象询问它的类时，并非直接到实例它的类，而是一个对象特有的隐藏类。这个类称为该对象的<strong>单件类</strong>。</p>
<p><code>Object#class</code>会把单件类隐藏起来。Ruby有一种特殊的基于class的关键字的语法，可以进入该单件类的作用域：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> &lt;&lt; an_object</span></span><br><span class="line">    <span class="comment"># ......</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>还可以通过<code>Object#singleton_class</code>方法来获得单件类的引用：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"abc"</span>.singleton_class 	<span class="comment"># =&gt; #&lt;Class:#&lt;String:0x331df0&gt;&gt;</span></span><br></pre></td></tr></table></figure>
<p>单件类也是类，是特殊的类。用<code>Object#singleton_class</code>方法或<code>class&lt;&lt; obj</code>语法获得它。同时，每个单件类只有一个实例，而且不能被继承。<strong>单件类是一个对象的单件方法的存活的地方</strong>。</p>
<p><strong>Ruby对象模型的七条规则</strong></p>
<ol>
<li>只有一种对象——要么是普通对象，要么是模块。</li>
<li>只有一种模块——可以是一个普通模块、一个类或者一个单件类。</li>
<li>只用一种方法，它存在于一个模块中——通常是一个类中。</li>
<li>每个对象（包括类）都有自己“真正的类”——要么是一个普通类，要么是一个单件类。</li>
<li>除了<code>BasicObject</code>类没有超类外，每个类有且只有一个祖先——要么是一个类，要么是一个模块。这意味着任何类只有一条向上的、直到<code>BasicObject</code>的祖先链。</li>
<li>一个对象的单件类的超类是这个对象的类；一个类的单件类的超类是这个类的超类的单件类。</li>
<li>调用一个方法时，Ruby先向右一步进入接收者真正的类，然后向上进入祖先链，这就是Ruby查找方法的方式。</li>
</ol>
</div></article></div></main><footer><div class="paginator"><a href="/2018/09/20/Ruby-处理Xml/" class="next">NEXT</a></div><div class="copyright"><p>© 2018 <a href="https://blog.ache.fun">阿扯</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/MikeCoder/hexo-theme-gandalfr" target="_blank">hexo-theme-gandalfr</a>.</p></div></footer></div><script src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/highlight.min.js" crossorigin="anonymous"></script><script src="//cdn.bootcss.com/jquery/3.1.1/jquery.js" crossorigin="anonymous"></script><script>$(document).ready(function() { $('pre').each(function(i, block) { hljs.highlightBlock(block); }); });</script></body></html>